Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> classdefs declarations fundefs instructions
Rule 2     declarations -> declarations declaration
Rule 3     declarations -> <empty>
Rule 4     declaration -> TYPE inits ;
Rule 5     declaration -> id classinits ;
Rule 6     declaration -> error ;
Rule 7     inits -> inits , init
Rule 8     inits -> init
Rule 9     init -> id = expression
Rule 10    classinits -> classinits , classinit
Rule 11    classinits -> classinit
Rule 12    classinit -> id
Rule 13    instructions -> instructions instruction
Rule 14    instructions -> instruction
Rule 15    instruction -> expression ;
Rule 16    instruction -> print_instr
Rule 17    instruction -> labeled_instr
Rule 18    instruction -> assignment
Rule 19    instruction -> choice_instr
Rule 20    instruction -> while_instr
Rule 21    instruction -> repeat_instr
Rule 22    instruction -> return_instr
Rule 23    instruction -> break_instr
Rule 24    instruction -> continue_instr
Rule 25    instruction -> compound_instr
Rule 26    print_instr -> PRINT expression ;
Rule 27    print_instr -> PRINT error ;
Rule 28    labeled_instr -> id : instruction
Rule 29    assignment -> access = expression ;
Rule 30    access -> id
Rule 31    access -> id . id
Rule 32    choice_instr -> IF ( condition ) instruction
Rule 33    choice_instr -> IF ( condition ) instruction ELSE instruction
Rule 34    choice_instr -> IF ( error ) instruction
Rule 35    choice_instr -> IF ( error ) instruction ELSE instruction
Rule 36    while_instr -> WHILE ( condition ) instruction
Rule 37    while_instr -> WHILE ( error ) instruction
Rule 38    repeat_instr -> REPEAT instructions UNTIL condition ;
Rule 39    return_instr -> RETURN expression ;
Rule 40    continue_instr -> CONTINUE ;
Rule 41    break_instr -> BREAK ;
Rule 42    compound_instr -> { declarations instructions }
Rule 43    condition -> expression
Rule 44    const -> integer
Rule 45    const -> float
Rule 46    const -> string
Rule 47    integer -> INTEGER
Rule 48    float -> FLOAT
Rule 49    string -> STRING
Rule 50    id -> ID
Rule 51    expression -> const
Rule 52    expression -> access
Rule 53    expression -> expression + expression
Rule 54    expression -> expression - expression
Rule 55    expression -> expression * expression
Rule 56    expression -> expression / expression
Rule 57    expression -> expression % expression
Rule 58    expression -> expression | expression
Rule 59    expression -> expression & expression
Rule 60    expression -> expression ^ expression
Rule 61    expression -> expression AND expression
Rule 62    expression -> expression OR expression
Rule 63    expression -> expression SHL expression
Rule 64    expression -> expression SHR expression
Rule 65    expression -> expression EQ expression
Rule 66    expression -> expression NEQ expression
Rule 67    expression -> expression > expression
Rule 68    expression -> expression < expression
Rule 69    expression -> expression LE expression
Rule 70    expression -> expression GE expression
Rule 71    expression -> ( expression )
Rule 72    expression -> ( error )
Rule 73    expression -> access ( expr_list_or_empty )
Rule 74    expression -> access ( error )
Rule 75    expr_list_or_empty -> expr_list
Rule 76    expr_list_or_empty -> <empty>
Rule 77    expr_list -> expr_list , expression
Rule 78    expr_list -> expression
Rule 79    fundefs -> fundef fundefs
Rule 80    fundefs -> <empty>
Rule 81    fundef -> TYPE id ( args_list_or_empty ) compound_instr
Rule 82    fundef -> id id ( args_list_or_empty ) compound_instr
Rule 83    args_list_or_empty -> args_list
Rule 84    args_list_or_empty -> <empty>
Rule 85    args_list -> args_list , arg
Rule 86    args_list -> arg
Rule 87    arg -> TYPE id
Rule 88    arg -> id id
Rule 89    classdefs -> classdef classdefs
Rule 90    classdefs -> <empty>
Rule 91    classdef -> accessmodificator CLASS id classcontent
Rule 92    classdef -> accessmodificator CLASS id EXTENDS id classcontent
Rule 93    classcontent -> { fielddefs ; methoddefs }
Rule 94    fielddefs -> fielddef fielddefs
Rule 95    fielddefs -> <empty>
Rule 96    fielddef -> accessmodificator declaration
Rule 97    methoddefs -> methoddef methoddefs
Rule 98    methoddefs -> <empty>
Rule 99    methoddef -> accessmodificator fundef
Rule 100   accessmodificator -> PRIVATE
Rule 101   accessmodificator -> PROTECTED
Rule 102   accessmodificator -> PUBLIC

Terminals, with rules where they appear

%                    : 57
&                    : 59
(                    : 32 33 34 35 36 37 71 72 73 74 81 82
)                    : 32 33 34 35 36 37 71 72 73 74 81 82
*                    : 55
+                    : 53
,                    : 7 10 77 85
-                    : 54
.                    : 31
/                    : 56
:                    : 28
;                    : 4 5 6 15 26 27 29 38 39 40 41 93
<                    : 68
=                    : 9 29
>                    : 67
AND                  : 61
BREAK                : 41
CLASS                : 91 92
CONTINUE             : 40
ELSE                 : 33 35
EQ                   : 65
EXTENDS              : 92
FLOAT                : 48
GE                   : 70
ID                   : 50
IF                   : 32 33 34 35
INTEGER              : 47
LE                   : 69
NEQ                  : 66
OR                   : 62
PRINT                : 26 27
PRIVATE              : 100
PROTECTED            : 101
PUBLIC               : 102
REPEAT               : 38
RETURN               : 39
SHL                  : 63
SHR                  : 64
STRING               : 49
TYPE                 : 4 81 87
UNTIL                : 38
WHILE                : 36 37
^                    : 60
error                : 6 27 34 35 37 72 74
{                    : 42 93
|                    : 58
}                    : 42 93

Nonterminals, with rules where they appear

access               : 29 52 73 74
accessmodificator    : 91 92 96 99
arg                  : 85 86
args_list            : 83 85
args_list_or_empty   : 81 82
assignment           : 18
break_instr          : 23
choice_instr         : 19
classcontent         : 91 92
classdef             : 89
classdefs            : 1 89
classinit            : 10 11
classinits           : 5 10
compound_instr       : 25 81 82
condition            : 32 33 36 38
const                : 51
continue_instr       : 24
declaration          : 2 96
declarations         : 1 2 42
expr_list            : 75 77
expr_list_or_empty   : 73
expression           : 9 15 26 29 39 43 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 77 78
fielddef             : 94
fielddefs            : 93 94
float                : 45
fundef               : 79 99
fundefs              : 1 79
id                   : 5 9 12 28 30 31 31 81 82 82 87 88 88 91 92 92
init                 : 7 8
inits                : 4 7
instruction          : 13 14 28 32 33 33 34 35 35 36 37
instructions         : 1 13 38 42
integer              : 44
labeled_instr        : 17
methoddef            : 97
methoddefs           : 93 97
print_instr          : 16
program              : 0
repeat_instr         : 21
return_instr         : 22
string               : 46
while_instr          : 20

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . classdefs declarations fundefs instructions
    (89) classdefs -> . classdef classdefs
    (90) classdefs -> .
    (91) classdef -> . accessmodificator CLASS id classcontent
    (92) classdef -> . accessmodificator CLASS id EXTENDS id classcontent
    (100) accessmodificator -> . PRIVATE
    (101) accessmodificator -> . PROTECTED
    (102) accessmodificator -> . PUBLIC

    TYPE            reduce using rule 90 (classdefs -> .)
    error           reduce using rule 90 (classdefs -> .)
    ID              reduce using rule 90 (classdefs -> .)
    (               reduce using rule 90 (classdefs -> .)
    PRINT           reduce using rule 90 (classdefs -> .)
    IF              reduce using rule 90 (classdefs -> .)
    WHILE           reduce using rule 90 (classdefs -> .)
    REPEAT          reduce using rule 90 (classdefs -> .)
    RETURN          reduce using rule 90 (classdefs -> .)
    BREAK           reduce using rule 90 (classdefs -> .)
    CONTINUE        reduce using rule 90 (classdefs -> .)
    {               reduce using rule 90 (classdefs -> .)
    INTEGER         reduce using rule 90 (classdefs -> .)
    FLOAT           reduce using rule 90 (classdefs -> .)
    STRING          reduce using rule 90 (classdefs -> .)
    PRIVATE         shift and go to state 3
    PROTECTED       shift and go to state 4
    PUBLIC          shift and go to state 7

    accessmodificator              shift and go to state 1
    classdef                       shift and go to state 2
    program                        shift and go to state 5
    classdefs                      shift and go to state 6

state 1

    (91) classdef -> accessmodificator . CLASS id classcontent
    (92) classdef -> accessmodificator . CLASS id EXTENDS id classcontent

    CLASS           shift and go to state 8


state 2

    (89) classdefs -> classdef . classdefs
    (89) classdefs -> . classdef classdefs
    (90) classdefs -> .
    (91) classdef -> . accessmodificator CLASS id classcontent
    (92) classdef -> . accessmodificator CLASS id EXTENDS id classcontent
    (100) accessmodificator -> . PRIVATE
    (101) accessmodificator -> . PROTECTED
    (102) accessmodificator -> . PUBLIC

    TYPE            reduce using rule 90 (classdefs -> .)
    error           reduce using rule 90 (classdefs -> .)
    ID              reduce using rule 90 (classdefs -> .)
    (               reduce using rule 90 (classdefs -> .)
    PRINT           reduce using rule 90 (classdefs -> .)
    IF              reduce using rule 90 (classdefs -> .)
    WHILE           reduce using rule 90 (classdefs -> .)
    REPEAT          reduce using rule 90 (classdefs -> .)
    RETURN          reduce using rule 90 (classdefs -> .)
    BREAK           reduce using rule 90 (classdefs -> .)
    CONTINUE        reduce using rule 90 (classdefs -> .)
    {               reduce using rule 90 (classdefs -> .)
    INTEGER         reduce using rule 90 (classdefs -> .)
    FLOAT           reduce using rule 90 (classdefs -> .)
    STRING          reduce using rule 90 (classdefs -> .)
    PRIVATE         shift and go to state 3
    PROTECTED       shift and go to state 4
    PUBLIC          shift and go to state 7

    accessmodificator              shift and go to state 1
    classdef                       shift and go to state 2
    classdefs                      shift and go to state 9

state 3

    (100) accessmodificator -> PRIVATE .

    CLASS           reduce using rule 100 (accessmodificator -> PRIVATE .)
    TYPE            reduce using rule 100 (accessmodificator -> PRIVATE .)
    error           reduce using rule 100 (accessmodificator -> PRIVATE .)
    ID              reduce using rule 100 (accessmodificator -> PRIVATE .)


state 4

    (101) accessmodificator -> PROTECTED .

    CLASS           reduce using rule 101 (accessmodificator -> PROTECTED .)
    TYPE            reduce using rule 101 (accessmodificator -> PROTECTED .)
    error           reduce using rule 101 (accessmodificator -> PROTECTED .)
    ID              reduce using rule 101 (accessmodificator -> PROTECTED .)


state 5

    (0) S' -> program .



state 6

    (1) program -> classdefs . declarations fundefs instructions
    (2) declarations -> . declarations declaration
    (3) declarations -> .

    TYPE            reduce using rule 3 (declarations -> .)
    error           reduce using rule 3 (declarations -> .)
    ID              reduce using rule 3 (declarations -> .)
    (               reduce using rule 3 (declarations -> .)
    PRINT           reduce using rule 3 (declarations -> .)
    IF              reduce using rule 3 (declarations -> .)
    WHILE           reduce using rule 3 (declarations -> .)
    REPEAT          reduce using rule 3 (declarations -> .)
    RETURN          reduce using rule 3 (declarations -> .)
    BREAK           reduce using rule 3 (declarations -> .)
    CONTINUE        reduce using rule 3 (declarations -> .)
    {               reduce using rule 3 (declarations -> .)
    INTEGER         reduce using rule 3 (declarations -> .)
    FLOAT           reduce using rule 3 (declarations -> .)
    STRING          reduce using rule 3 (declarations -> .)

    declarations                   shift and go to state 10

state 7

    (102) accessmodificator -> PUBLIC .

    CLASS           reduce using rule 102 (accessmodificator -> PUBLIC .)
    TYPE            reduce using rule 102 (accessmodificator -> PUBLIC .)
    error           reduce using rule 102 (accessmodificator -> PUBLIC .)
    ID              reduce using rule 102 (accessmodificator -> PUBLIC .)


state 8

    (91) classdef -> accessmodificator CLASS . id classcontent
    (92) classdef -> accessmodificator CLASS . id EXTENDS id classcontent
    (50) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 12

state 9

    (89) classdefs -> classdef classdefs .

    TYPE            reduce using rule 89 (classdefs -> classdef classdefs .)
    error           reduce using rule 89 (classdefs -> classdef classdefs .)
    ID              reduce using rule 89 (classdefs -> classdef classdefs .)
    (               reduce using rule 89 (classdefs -> classdef classdefs .)
    PRINT           reduce using rule 89 (classdefs -> classdef classdefs .)
    IF              reduce using rule 89 (classdefs -> classdef classdefs .)
    WHILE           reduce using rule 89 (classdefs -> classdef classdefs .)
    REPEAT          reduce using rule 89 (classdefs -> classdef classdefs .)
    RETURN          reduce using rule 89 (classdefs -> classdef classdefs .)
    BREAK           reduce using rule 89 (classdefs -> classdef classdefs .)
    CONTINUE        reduce using rule 89 (classdefs -> classdef classdefs .)
    {               reduce using rule 89 (classdefs -> classdef classdefs .)
    INTEGER         reduce using rule 89 (classdefs -> classdef classdefs .)
    FLOAT           reduce using rule 89 (classdefs -> classdef classdefs .)
    STRING          reduce using rule 89 (classdefs -> classdef classdefs .)


state 10

    (1) program -> classdefs declarations . fundefs instructions
    (2) declarations -> declarations . declaration
    (79) fundefs -> . fundef fundefs
    (80) fundefs -> .
    (4) declaration -> . TYPE inits ;
    (5) declaration -> . id classinits ;
    (6) declaration -> . error ;
    (81) fundef -> . TYPE id ( args_list_or_empty ) compound_instr
    (82) fundef -> . id id ( args_list_or_empty ) compound_instr
    (50) id -> . ID

  ! shift/reduce conflict for ID resolved as shift
    (               reduce using rule 80 (fundefs -> .)
    PRINT           reduce using rule 80 (fundefs -> .)
    IF              reduce using rule 80 (fundefs -> .)
    WHILE           reduce using rule 80 (fundefs -> .)
    REPEAT          reduce using rule 80 (fundefs -> .)
    RETURN          reduce using rule 80 (fundefs -> .)
    BREAK           reduce using rule 80 (fundefs -> .)
    CONTINUE        reduce using rule 80 (fundefs -> .)
    {               reduce using rule 80 (fundefs -> .)
    INTEGER         reduce using rule 80 (fundefs -> .)
    FLOAT           reduce using rule 80 (fundefs -> .)
    STRING          reduce using rule 80 (fundefs -> .)
    TYPE            shift and go to state 17
    error           shift and go to state 15
    ID              shift and go to state 11

  ! ID              [ reduce using rule 80 (fundefs -> .) ]

    fundefs                        shift and go to state 13
    fundef                         shift and go to state 14
    declaration                    shift and go to state 16
    id                             shift and go to state 18

state 11

    (50) id -> ID .

    .               reduce using rule 50 (id -> ID .)
    (               reduce using rule 50 (id -> ID .)
    +               reduce using rule 50 (id -> ID .)
    -               reduce using rule 50 (id -> ID .)
    *               reduce using rule 50 (id -> ID .)
    /               reduce using rule 50 (id -> ID .)
    %               reduce using rule 50 (id -> ID .)
    |               reduce using rule 50 (id -> ID .)
    &               reduce using rule 50 (id -> ID .)
    ^               reduce using rule 50 (id -> ID .)
    AND             reduce using rule 50 (id -> ID .)
    OR              reduce using rule 50 (id -> ID .)
    SHL             reduce using rule 50 (id -> ID .)
    SHR             reduce using rule 50 (id -> ID .)
    EQ              reduce using rule 50 (id -> ID .)
    NEQ             reduce using rule 50 (id -> ID .)
    >               reduce using rule 50 (id -> ID .)
    <               reduce using rule 50 (id -> ID .)
    LE              reduce using rule 50 (id -> ID .)
    GE              reduce using rule 50 (id -> ID .)
    ;               reduce using rule 50 (id -> ID .)
    )               reduce using rule 50 (id -> ID .)
    ,               reduce using rule 50 (id -> ID .)
    :               reduce using rule 50 (id -> ID .)
    =               reduce using rule 50 (id -> ID .)
    ID              reduce using rule 50 (id -> ID .)
    EXTENDS         reduce using rule 50 (id -> ID .)
    {               reduce using rule 50 (id -> ID .)


state 12

    (91) classdef -> accessmodificator CLASS id . classcontent
    (92) classdef -> accessmodificator CLASS id . EXTENDS id classcontent
    (93) classcontent -> . { fielddefs ; methoddefs }

    EXTENDS         shift and go to state 20
    {               shift and go to state 21

    classcontent                   shift and go to state 19

state 13

    (1) program -> classdefs declarations fundefs . instructions
    (13) instructions -> . instructions instruction
    (14) instructions -> . instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 22
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    instructions                   shift and go to state 44
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 14

    (79) fundefs -> fundef . fundefs
    (79) fundefs -> . fundef fundefs
    (80) fundefs -> .
    (81) fundef -> . TYPE id ( args_list_or_empty ) compound_instr
    (82) fundef -> . id id ( args_list_or_empty ) compound_instr
    (50) id -> . ID

  ! shift/reduce conflict for ID resolved as shift
    (               reduce using rule 80 (fundefs -> .)
    PRINT           reduce using rule 80 (fundefs -> .)
    IF              reduce using rule 80 (fundefs -> .)
    WHILE           reduce using rule 80 (fundefs -> .)
    REPEAT          reduce using rule 80 (fundefs -> .)
    RETURN          reduce using rule 80 (fundefs -> .)
    BREAK           reduce using rule 80 (fundefs -> .)
    CONTINUE        reduce using rule 80 (fundefs -> .)
    {               reduce using rule 80 (fundefs -> .)
    INTEGER         reduce using rule 80 (fundefs -> .)
    FLOAT           reduce using rule 80 (fundefs -> .)
    STRING          reduce using rule 80 (fundefs -> .)
    TYPE            shift and go to state 54
    ID              shift and go to state 11

  ! ID              [ reduce using rule 80 (fundefs -> .) ]

    fundefs                        shift and go to state 53
    id                             shift and go to state 55
    fundef                         shift and go to state 14

state 15

    (6) declaration -> error . ;

    ;               shift and go to state 56


state 16

    (2) declarations -> declarations declaration .

    TYPE            reduce using rule 2 (declarations -> declarations declaration .)
    error           reduce using rule 2 (declarations -> declarations declaration .)
    ID              reduce using rule 2 (declarations -> declarations declaration .)
    (               reduce using rule 2 (declarations -> declarations declaration .)
    PRINT           reduce using rule 2 (declarations -> declarations declaration .)
    IF              reduce using rule 2 (declarations -> declarations declaration .)
    WHILE           reduce using rule 2 (declarations -> declarations declaration .)
    REPEAT          reduce using rule 2 (declarations -> declarations declaration .)
    RETURN          reduce using rule 2 (declarations -> declarations declaration .)
    BREAK           reduce using rule 2 (declarations -> declarations declaration .)
    CONTINUE        reduce using rule 2 (declarations -> declarations declaration .)
    {               reduce using rule 2 (declarations -> declarations declaration .)
    INTEGER         reduce using rule 2 (declarations -> declarations declaration .)
    FLOAT           reduce using rule 2 (declarations -> declarations declaration .)
    STRING          reduce using rule 2 (declarations -> declarations declaration .)


state 17

    (4) declaration -> TYPE . inits ;
    (81) fundef -> TYPE . id ( args_list_or_empty ) compound_instr
    (7) inits -> . inits , init
    (8) inits -> . init
    (50) id -> . ID
    (9) init -> . id = expression

    ID              shift and go to state 11

    init                           shift and go to state 57
    inits                          shift and go to state 58
    id                             shift and go to state 59

state 18

    (5) declaration -> id . classinits ;
    (82) fundef -> id . id ( args_list_or_empty ) compound_instr
    (10) classinits -> . classinits , classinit
    (11) classinits -> . classinit
    (50) id -> . ID
    (12) classinit -> . id

    ID              shift and go to state 11

    classinits                     shift and go to state 60
    id                             shift and go to state 62
    classinit                      shift and go to state 61

state 19

    (91) classdef -> accessmodificator CLASS id classcontent .

    PRIVATE         reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    PROTECTED       reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    PUBLIC          reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    TYPE            reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    error           reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    ID              reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    (               reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    PRINT           reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    IF              reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    WHILE           reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    REPEAT          reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    RETURN          reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    BREAK           reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    CONTINUE        reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    {               reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    INTEGER         reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    FLOAT           reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)
    STRING          reduce using rule 91 (classdef -> accessmodificator CLASS id classcontent .)


state 20

    (92) classdef -> accessmodificator CLASS id EXTENDS . id classcontent
    (50) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 63

state 21

    (93) classcontent -> { . fielddefs ; methoddefs }
    (94) fielddefs -> . fielddef fielddefs
    (95) fielddefs -> .
    (96) fielddef -> . accessmodificator declaration
    (100) accessmodificator -> . PRIVATE
    (101) accessmodificator -> . PROTECTED
    (102) accessmodificator -> . PUBLIC

    ;               reduce using rule 95 (fielddefs -> .)
    PRIVATE         shift and go to state 3
    PROTECTED       shift and go to state 4
    PUBLIC          shift and go to state 7

    fielddefs                      shift and go to state 66
    accessmodificator              shift and go to state 65
    fielddef                       shift and go to state 64

state 22

    (14) instructions -> instruction .

    }               reduce using rule 14 (instructions -> instruction .)
    (               reduce using rule 14 (instructions -> instruction .)
    PRINT           reduce using rule 14 (instructions -> instruction .)
    IF              reduce using rule 14 (instructions -> instruction .)
    WHILE           reduce using rule 14 (instructions -> instruction .)
    REPEAT          reduce using rule 14 (instructions -> instruction .)
    RETURN          reduce using rule 14 (instructions -> instruction .)
    BREAK           reduce using rule 14 (instructions -> instruction .)
    CONTINUE        reduce using rule 14 (instructions -> instruction .)
    {               reduce using rule 14 (instructions -> instruction .)
    ID              reduce using rule 14 (instructions -> instruction .)
    INTEGER         reduce using rule 14 (instructions -> instruction .)
    FLOAT           reduce using rule 14 (instructions -> instruction .)
    STRING          reduce using rule 14 (instructions -> instruction .)
    $end            reduce using rule 14 (instructions -> instruction .)
    UNTIL           reduce using rule 14 (instructions -> instruction .)


state 23

    (39) return_instr -> RETURN . expression ;
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 69
    id                             shift and go to state 67

state 24

    (45) const -> float .

    ;               reduce using rule 45 (const -> float .)
    +               reduce using rule 45 (const -> float .)
    -               reduce using rule 45 (const -> float .)
    *               reduce using rule 45 (const -> float .)
    /               reduce using rule 45 (const -> float .)
    %               reduce using rule 45 (const -> float .)
    |               reduce using rule 45 (const -> float .)
    &               reduce using rule 45 (const -> float .)
    ^               reduce using rule 45 (const -> float .)
    AND             reduce using rule 45 (const -> float .)
    OR              reduce using rule 45 (const -> float .)
    SHL             reduce using rule 45 (const -> float .)
    SHR             reduce using rule 45 (const -> float .)
    EQ              reduce using rule 45 (const -> float .)
    NEQ             reduce using rule 45 (const -> float .)
    >               reduce using rule 45 (const -> float .)
    <               reduce using rule 45 (const -> float .)
    LE              reduce using rule 45 (const -> float .)
    GE              reduce using rule 45 (const -> float .)
    )               reduce using rule 45 (const -> float .)
    ,               reduce using rule 45 (const -> float .)


state 25

    (19) instruction -> choice_instr .

    UNTIL           reduce using rule 19 (instruction -> choice_instr .)
    (               reduce using rule 19 (instruction -> choice_instr .)
    PRINT           reduce using rule 19 (instruction -> choice_instr .)
    IF              reduce using rule 19 (instruction -> choice_instr .)
    WHILE           reduce using rule 19 (instruction -> choice_instr .)
    REPEAT          reduce using rule 19 (instruction -> choice_instr .)
    RETURN          reduce using rule 19 (instruction -> choice_instr .)
    BREAK           reduce using rule 19 (instruction -> choice_instr .)
    CONTINUE        reduce using rule 19 (instruction -> choice_instr .)
    {               reduce using rule 19 (instruction -> choice_instr .)
    ID              reduce using rule 19 (instruction -> choice_instr .)
    INTEGER         reduce using rule 19 (instruction -> choice_instr .)
    FLOAT           reduce using rule 19 (instruction -> choice_instr .)
    STRING          reduce using rule 19 (instruction -> choice_instr .)
    $end            reduce using rule 19 (instruction -> choice_instr .)
    }               reduce using rule 19 (instruction -> choice_instr .)
    ELSE            reduce using rule 19 (instruction -> choice_instr .)


state 26

    (49) string -> STRING .

    ;               reduce using rule 49 (string -> STRING .)
    +               reduce using rule 49 (string -> STRING .)
    -               reduce using rule 49 (string -> STRING .)
    *               reduce using rule 49 (string -> STRING .)
    /               reduce using rule 49 (string -> STRING .)
    %               reduce using rule 49 (string -> STRING .)
    |               reduce using rule 49 (string -> STRING .)
    &               reduce using rule 49 (string -> STRING .)
    ^               reduce using rule 49 (string -> STRING .)
    AND             reduce using rule 49 (string -> STRING .)
    OR              reduce using rule 49 (string -> STRING .)
    SHL             reduce using rule 49 (string -> STRING .)
    SHR             reduce using rule 49 (string -> STRING .)
    EQ              reduce using rule 49 (string -> STRING .)
    NEQ             reduce using rule 49 (string -> STRING .)
    >               reduce using rule 49 (string -> STRING .)
    <               reduce using rule 49 (string -> STRING .)
    LE              reduce using rule 49 (string -> STRING .)
    GE              reduce using rule 49 (string -> STRING .)
    )               reduce using rule 49 (string -> STRING .)
    ,               reduce using rule 49 (string -> STRING .)


state 27

    (32) choice_instr -> IF . ( condition ) instruction
    (33) choice_instr -> IF . ( condition ) instruction ELSE instruction
    (34) choice_instr -> IF . ( error ) instruction
    (35) choice_instr -> IF . ( error ) instruction ELSE instruction

    (               shift and go to state 70


state 28

    (44) const -> integer .

    ;               reduce using rule 44 (const -> integer .)
    +               reduce using rule 44 (const -> integer .)
    -               reduce using rule 44 (const -> integer .)
    *               reduce using rule 44 (const -> integer .)
    /               reduce using rule 44 (const -> integer .)
    %               reduce using rule 44 (const -> integer .)
    |               reduce using rule 44 (const -> integer .)
    &               reduce using rule 44 (const -> integer .)
    ^               reduce using rule 44 (const -> integer .)
    AND             reduce using rule 44 (const -> integer .)
    OR              reduce using rule 44 (const -> integer .)
    SHL             reduce using rule 44 (const -> integer .)
    SHR             reduce using rule 44 (const -> integer .)
    EQ              reduce using rule 44 (const -> integer .)
    NEQ             reduce using rule 44 (const -> integer .)
    >               reduce using rule 44 (const -> integer .)
    <               reduce using rule 44 (const -> integer .)
    LE              reduce using rule 44 (const -> integer .)
    GE              reduce using rule 44 (const -> integer .)
    )               reduce using rule 44 (const -> integer .)
    ,               reduce using rule 44 (const -> integer .)


state 29

    (26) print_instr -> PRINT . expression ;
    (27) print_instr -> PRINT . error ;
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    error           shift and go to state 71
    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 72
    id                             shift and go to state 67

state 30

    (36) while_instr -> WHILE . ( condition ) instruction
    (37) while_instr -> WHILE . ( error ) instruction

    (               shift and go to state 73


state 31

    (28) labeled_instr -> id . : instruction
    (30) access -> id .
    (31) access -> id . . id

    :               shift and go to state 74
    (               reduce using rule 30 (access -> id .)
    =               reduce using rule 30 (access -> id .)
    ;               reduce using rule 30 (access -> id .)
    +               reduce using rule 30 (access -> id .)
    -               reduce using rule 30 (access -> id .)
    *               reduce using rule 30 (access -> id .)
    /               reduce using rule 30 (access -> id .)
    %               reduce using rule 30 (access -> id .)
    |               reduce using rule 30 (access -> id .)
    &               reduce using rule 30 (access -> id .)
    ^               reduce using rule 30 (access -> id .)
    AND             reduce using rule 30 (access -> id .)
    OR              reduce using rule 30 (access -> id .)
    SHL             reduce using rule 30 (access -> id .)
    SHR             reduce using rule 30 (access -> id .)
    EQ              reduce using rule 30 (access -> id .)
    NEQ             reduce using rule 30 (access -> id .)
    >               reduce using rule 30 (access -> id .)
    <               reduce using rule 30 (access -> id .)
    LE              reduce using rule 30 (access -> id .)
    GE              reduce using rule 30 (access -> id .)
    .               shift and go to state 75


state 32

    (21) instruction -> repeat_instr .

    UNTIL           reduce using rule 21 (instruction -> repeat_instr .)
    (               reduce using rule 21 (instruction -> repeat_instr .)
    PRINT           reduce using rule 21 (instruction -> repeat_instr .)
    IF              reduce using rule 21 (instruction -> repeat_instr .)
    WHILE           reduce using rule 21 (instruction -> repeat_instr .)
    REPEAT          reduce using rule 21 (instruction -> repeat_instr .)
    RETURN          reduce using rule 21 (instruction -> repeat_instr .)
    BREAK           reduce using rule 21 (instruction -> repeat_instr .)
    CONTINUE        reduce using rule 21 (instruction -> repeat_instr .)
    {               reduce using rule 21 (instruction -> repeat_instr .)
    ID              reduce using rule 21 (instruction -> repeat_instr .)
    INTEGER         reduce using rule 21 (instruction -> repeat_instr .)
    FLOAT           reduce using rule 21 (instruction -> repeat_instr .)
    STRING          reduce using rule 21 (instruction -> repeat_instr .)
    $end            reduce using rule 21 (instruction -> repeat_instr .)
    }               reduce using rule 21 (instruction -> repeat_instr .)
    ELSE            reduce using rule 21 (instruction -> repeat_instr .)


state 33

    (22) instruction -> return_instr .

    UNTIL           reduce using rule 22 (instruction -> return_instr .)
    (               reduce using rule 22 (instruction -> return_instr .)
    PRINT           reduce using rule 22 (instruction -> return_instr .)
    IF              reduce using rule 22 (instruction -> return_instr .)
    WHILE           reduce using rule 22 (instruction -> return_instr .)
    REPEAT          reduce using rule 22 (instruction -> return_instr .)
    RETURN          reduce using rule 22 (instruction -> return_instr .)
    BREAK           reduce using rule 22 (instruction -> return_instr .)
    CONTINUE        reduce using rule 22 (instruction -> return_instr .)
    {               reduce using rule 22 (instruction -> return_instr .)
    ID              reduce using rule 22 (instruction -> return_instr .)
    INTEGER         reduce using rule 22 (instruction -> return_instr .)
    FLOAT           reduce using rule 22 (instruction -> return_instr .)
    STRING          reduce using rule 22 (instruction -> return_instr .)
    $end            reduce using rule 22 (instruction -> return_instr .)
    }               reduce using rule 22 (instruction -> return_instr .)
    ELSE            reduce using rule 22 (instruction -> return_instr .)


state 34

    (51) expression -> const .

    +               reduce using rule 51 (expression -> const .)
    -               reduce using rule 51 (expression -> const .)
    *               reduce using rule 51 (expression -> const .)
    /               reduce using rule 51 (expression -> const .)
    %               reduce using rule 51 (expression -> const .)
    |               reduce using rule 51 (expression -> const .)
    &               reduce using rule 51 (expression -> const .)
    ^               reduce using rule 51 (expression -> const .)
    AND             reduce using rule 51 (expression -> const .)
    OR              reduce using rule 51 (expression -> const .)
    SHL             reduce using rule 51 (expression -> const .)
    SHR             reduce using rule 51 (expression -> const .)
    EQ              reduce using rule 51 (expression -> const .)
    NEQ             reduce using rule 51 (expression -> const .)
    >               reduce using rule 51 (expression -> const .)
    <               reduce using rule 51 (expression -> const .)
    LE              reduce using rule 51 (expression -> const .)
    GE              reduce using rule 51 (expression -> const .)
    ;               reduce using rule 51 (expression -> const .)
    )               reduce using rule 51 (expression -> const .)
    ,               reduce using rule 51 (expression -> const .)


state 35

    (24) instruction -> continue_instr .

    UNTIL           reduce using rule 24 (instruction -> continue_instr .)
    (               reduce using rule 24 (instruction -> continue_instr .)
    PRINT           reduce using rule 24 (instruction -> continue_instr .)
    IF              reduce using rule 24 (instruction -> continue_instr .)
    WHILE           reduce using rule 24 (instruction -> continue_instr .)
    REPEAT          reduce using rule 24 (instruction -> continue_instr .)
    RETURN          reduce using rule 24 (instruction -> continue_instr .)
    BREAK           reduce using rule 24 (instruction -> continue_instr .)
    CONTINUE        reduce using rule 24 (instruction -> continue_instr .)
    {               reduce using rule 24 (instruction -> continue_instr .)
    ID              reduce using rule 24 (instruction -> continue_instr .)
    INTEGER         reduce using rule 24 (instruction -> continue_instr .)
    FLOAT           reduce using rule 24 (instruction -> continue_instr .)
    STRING          reduce using rule 24 (instruction -> continue_instr .)
    $end            reduce using rule 24 (instruction -> continue_instr .)
    }               reduce using rule 24 (instruction -> continue_instr .)
    ELSE            reduce using rule 24 (instruction -> continue_instr .)


state 36

    (20) instruction -> while_instr .

    UNTIL           reduce using rule 20 (instruction -> while_instr .)
    (               reduce using rule 20 (instruction -> while_instr .)
    PRINT           reduce using rule 20 (instruction -> while_instr .)
    IF              reduce using rule 20 (instruction -> while_instr .)
    WHILE           reduce using rule 20 (instruction -> while_instr .)
    REPEAT          reduce using rule 20 (instruction -> while_instr .)
    RETURN          reduce using rule 20 (instruction -> while_instr .)
    BREAK           reduce using rule 20 (instruction -> while_instr .)
    CONTINUE        reduce using rule 20 (instruction -> while_instr .)
    {               reduce using rule 20 (instruction -> while_instr .)
    ID              reduce using rule 20 (instruction -> while_instr .)
    INTEGER         reduce using rule 20 (instruction -> while_instr .)
    FLOAT           reduce using rule 20 (instruction -> while_instr .)
    STRING          reduce using rule 20 (instruction -> while_instr .)
    $end            reduce using rule 20 (instruction -> while_instr .)
    }               reduce using rule 20 (instruction -> while_instr .)
    ELSE            reduce using rule 20 (instruction -> while_instr .)


state 37

    (52) expression -> access .
    (73) expression -> access . ( expr_list_or_empty )
    (74) expression -> access . ( error )
    (29) assignment -> access . = expression ;

    ;               reduce using rule 52 (expression -> access .)
    +               reduce using rule 52 (expression -> access .)
    -               reduce using rule 52 (expression -> access .)
    *               reduce using rule 52 (expression -> access .)
    /               reduce using rule 52 (expression -> access .)
    %               reduce using rule 52 (expression -> access .)
    |               reduce using rule 52 (expression -> access .)
    &               reduce using rule 52 (expression -> access .)
    ^               reduce using rule 52 (expression -> access .)
    AND             reduce using rule 52 (expression -> access .)
    OR              reduce using rule 52 (expression -> access .)
    SHL             reduce using rule 52 (expression -> access .)
    SHR             reduce using rule 52 (expression -> access .)
    EQ              reduce using rule 52 (expression -> access .)
    NEQ             reduce using rule 52 (expression -> access .)
    >               reduce using rule 52 (expression -> access .)
    <               reduce using rule 52 (expression -> access .)
    LE              reduce using rule 52 (expression -> access .)
    GE              reduce using rule 52 (expression -> access .)
    (               shift and go to state 76
    =               shift and go to state 77


state 38

    (47) integer -> INTEGER .

    )               reduce using rule 47 (integer -> INTEGER .)
    +               reduce using rule 47 (integer -> INTEGER .)
    -               reduce using rule 47 (integer -> INTEGER .)
    *               reduce using rule 47 (integer -> INTEGER .)
    /               reduce using rule 47 (integer -> INTEGER .)
    %               reduce using rule 47 (integer -> INTEGER .)
    |               reduce using rule 47 (integer -> INTEGER .)
    &               reduce using rule 47 (integer -> INTEGER .)
    ^               reduce using rule 47 (integer -> INTEGER .)
    AND             reduce using rule 47 (integer -> INTEGER .)
    OR              reduce using rule 47 (integer -> INTEGER .)
    SHL             reduce using rule 47 (integer -> INTEGER .)
    SHR             reduce using rule 47 (integer -> INTEGER .)
    EQ              reduce using rule 47 (integer -> INTEGER .)
    NEQ             reduce using rule 47 (integer -> INTEGER .)
    >               reduce using rule 47 (integer -> INTEGER .)
    <               reduce using rule 47 (integer -> INTEGER .)
    LE              reduce using rule 47 (integer -> INTEGER .)
    GE              reduce using rule 47 (integer -> INTEGER .)
    ;               reduce using rule 47 (integer -> INTEGER .)
    ,               reduce using rule 47 (integer -> INTEGER .)


state 39

    (38) repeat_instr -> REPEAT . instructions UNTIL condition ;
    (13) instructions -> . instructions instruction
    (14) instructions -> . instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 22
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    instructions                   shift and go to state 78
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 40

    (46) const -> string .

    ;               reduce using rule 46 (const -> string .)
    +               reduce using rule 46 (const -> string .)
    -               reduce using rule 46 (const -> string .)
    *               reduce using rule 46 (const -> string .)
    /               reduce using rule 46 (const -> string .)
    %               reduce using rule 46 (const -> string .)
    |               reduce using rule 46 (const -> string .)
    &               reduce using rule 46 (const -> string .)
    ^               reduce using rule 46 (const -> string .)
    AND             reduce using rule 46 (const -> string .)
    OR              reduce using rule 46 (const -> string .)
    SHL             reduce using rule 46 (const -> string .)
    SHR             reduce using rule 46 (const -> string .)
    EQ              reduce using rule 46 (const -> string .)
    NEQ             reduce using rule 46 (const -> string .)
    >               reduce using rule 46 (const -> string .)
    <               reduce using rule 46 (const -> string .)
    LE              reduce using rule 46 (const -> string .)
    GE              reduce using rule 46 (const -> string .)
    )               reduce using rule 46 (const -> string .)
    ,               reduce using rule 46 (const -> string .)


state 41

    (18) instruction -> assignment .

    UNTIL           reduce using rule 18 (instruction -> assignment .)
    (               reduce using rule 18 (instruction -> assignment .)
    PRINT           reduce using rule 18 (instruction -> assignment .)
    IF              reduce using rule 18 (instruction -> assignment .)
    WHILE           reduce using rule 18 (instruction -> assignment .)
    REPEAT          reduce using rule 18 (instruction -> assignment .)
    RETURN          reduce using rule 18 (instruction -> assignment .)
    BREAK           reduce using rule 18 (instruction -> assignment .)
    CONTINUE        reduce using rule 18 (instruction -> assignment .)
    {               reduce using rule 18 (instruction -> assignment .)
    ID              reduce using rule 18 (instruction -> assignment .)
    INTEGER         reduce using rule 18 (instruction -> assignment .)
    FLOAT           reduce using rule 18 (instruction -> assignment .)
    STRING          reduce using rule 18 (instruction -> assignment .)
    $end            reduce using rule 18 (instruction -> assignment .)
    }               reduce using rule 18 (instruction -> assignment .)
    ELSE            reduce using rule 18 (instruction -> assignment .)


state 42

    (17) instruction -> labeled_instr .

    UNTIL           reduce using rule 17 (instruction -> labeled_instr .)
    (               reduce using rule 17 (instruction -> labeled_instr .)
    PRINT           reduce using rule 17 (instruction -> labeled_instr .)
    IF              reduce using rule 17 (instruction -> labeled_instr .)
    WHILE           reduce using rule 17 (instruction -> labeled_instr .)
    REPEAT          reduce using rule 17 (instruction -> labeled_instr .)
    RETURN          reduce using rule 17 (instruction -> labeled_instr .)
    BREAK           reduce using rule 17 (instruction -> labeled_instr .)
    CONTINUE        reduce using rule 17 (instruction -> labeled_instr .)
    {               reduce using rule 17 (instruction -> labeled_instr .)
    ID              reduce using rule 17 (instruction -> labeled_instr .)
    INTEGER         reduce using rule 17 (instruction -> labeled_instr .)
    FLOAT           reduce using rule 17 (instruction -> labeled_instr .)
    STRING          reduce using rule 17 (instruction -> labeled_instr .)
    $end            reduce using rule 17 (instruction -> labeled_instr .)
    }               reduce using rule 17 (instruction -> labeled_instr .)
    ELSE            reduce using rule 17 (instruction -> labeled_instr .)


state 43

    (25) instruction -> compound_instr .

    UNTIL           reduce using rule 25 (instruction -> compound_instr .)
    (               reduce using rule 25 (instruction -> compound_instr .)
    PRINT           reduce using rule 25 (instruction -> compound_instr .)
    IF              reduce using rule 25 (instruction -> compound_instr .)
    WHILE           reduce using rule 25 (instruction -> compound_instr .)
    REPEAT          reduce using rule 25 (instruction -> compound_instr .)
    RETURN          reduce using rule 25 (instruction -> compound_instr .)
    BREAK           reduce using rule 25 (instruction -> compound_instr .)
    CONTINUE        reduce using rule 25 (instruction -> compound_instr .)
    {               reduce using rule 25 (instruction -> compound_instr .)
    ID              reduce using rule 25 (instruction -> compound_instr .)
    INTEGER         reduce using rule 25 (instruction -> compound_instr .)
    FLOAT           reduce using rule 25 (instruction -> compound_instr .)
    STRING          reduce using rule 25 (instruction -> compound_instr .)
    $end            reduce using rule 25 (instruction -> compound_instr .)
    }               reduce using rule 25 (instruction -> compound_instr .)
    ELSE            reduce using rule 25 (instruction -> compound_instr .)


state 44

    (1) program -> classdefs declarations fundefs instructions .
    (13) instructions -> instructions . instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    $end            reduce using rule 1 (program -> classdefs declarations fundefs instructions .)
    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 79
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 45

    (48) float -> FLOAT .

    +               reduce using rule 48 (float -> FLOAT .)
    -               reduce using rule 48 (float -> FLOAT .)
    *               reduce using rule 48 (float -> FLOAT .)
    /               reduce using rule 48 (float -> FLOAT .)
    %               reduce using rule 48 (float -> FLOAT .)
    |               reduce using rule 48 (float -> FLOAT .)
    &               reduce using rule 48 (float -> FLOAT .)
    ^               reduce using rule 48 (float -> FLOAT .)
    AND             reduce using rule 48 (float -> FLOAT .)
    OR              reduce using rule 48 (float -> FLOAT .)
    SHL             reduce using rule 48 (float -> FLOAT .)
    SHR             reduce using rule 48 (float -> FLOAT .)
    EQ              reduce using rule 48 (float -> FLOAT .)
    NEQ             reduce using rule 48 (float -> FLOAT .)
    >               reduce using rule 48 (float -> FLOAT .)
    <               reduce using rule 48 (float -> FLOAT .)
    LE              reduce using rule 48 (float -> FLOAT .)
    GE              reduce using rule 48 (float -> FLOAT .)
    )               reduce using rule 48 (float -> FLOAT .)
    ;               reduce using rule 48 (float -> FLOAT .)
    ,               reduce using rule 48 (float -> FLOAT .)


state 46

    (23) instruction -> break_instr .

    UNTIL           reduce using rule 23 (instruction -> break_instr .)
    (               reduce using rule 23 (instruction -> break_instr .)
    PRINT           reduce using rule 23 (instruction -> break_instr .)
    IF              reduce using rule 23 (instruction -> break_instr .)
    WHILE           reduce using rule 23 (instruction -> break_instr .)
    REPEAT          reduce using rule 23 (instruction -> break_instr .)
    RETURN          reduce using rule 23 (instruction -> break_instr .)
    BREAK           reduce using rule 23 (instruction -> break_instr .)
    CONTINUE        reduce using rule 23 (instruction -> break_instr .)
    {               reduce using rule 23 (instruction -> break_instr .)
    ID              reduce using rule 23 (instruction -> break_instr .)
    INTEGER         reduce using rule 23 (instruction -> break_instr .)
    FLOAT           reduce using rule 23 (instruction -> break_instr .)
    STRING          reduce using rule 23 (instruction -> break_instr .)
    $end            reduce using rule 23 (instruction -> break_instr .)
    }               reduce using rule 23 (instruction -> break_instr .)
    ELSE            reduce using rule 23 (instruction -> break_instr .)


state 47

    (41) break_instr -> BREAK . ;

    ;               shift and go to state 80


state 48

    (16) instruction -> print_instr .

    UNTIL           reduce using rule 16 (instruction -> print_instr .)
    (               reduce using rule 16 (instruction -> print_instr .)
    PRINT           reduce using rule 16 (instruction -> print_instr .)
    IF              reduce using rule 16 (instruction -> print_instr .)
    WHILE           reduce using rule 16 (instruction -> print_instr .)
    REPEAT          reduce using rule 16 (instruction -> print_instr .)
    RETURN          reduce using rule 16 (instruction -> print_instr .)
    BREAK           reduce using rule 16 (instruction -> print_instr .)
    CONTINUE        reduce using rule 16 (instruction -> print_instr .)
    {               reduce using rule 16 (instruction -> print_instr .)
    ID              reduce using rule 16 (instruction -> print_instr .)
    INTEGER         reduce using rule 16 (instruction -> print_instr .)
    FLOAT           reduce using rule 16 (instruction -> print_instr .)
    STRING          reduce using rule 16 (instruction -> print_instr .)
    $end            reduce using rule 16 (instruction -> print_instr .)
    }               reduce using rule 16 (instruction -> print_instr .)
    ELSE            reduce using rule 16 (instruction -> print_instr .)


state 49

    (40) continue_instr -> CONTINUE . ;

    ;               shift and go to state 81


state 50

    (71) expression -> ( . expression )
    (72) expression -> ( . error )
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    error           shift and go to state 82
    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 83
    id                             shift and go to state 67

state 51

    (42) compound_instr -> { . declarations instructions }
    (2) declarations -> . declarations declaration
    (3) declarations -> .

    TYPE            reduce using rule 3 (declarations -> .)
    error           reduce using rule 3 (declarations -> .)
    ID              reduce using rule 3 (declarations -> .)
    (               reduce using rule 3 (declarations -> .)
    PRINT           reduce using rule 3 (declarations -> .)
    IF              reduce using rule 3 (declarations -> .)
    WHILE           reduce using rule 3 (declarations -> .)
    REPEAT          reduce using rule 3 (declarations -> .)
    RETURN          reduce using rule 3 (declarations -> .)
    BREAK           reduce using rule 3 (declarations -> .)
    CONTINUE        reduce using rule 3 (declarations -> .)
    {               reduce using rule 3 (declarations -> .)
    INTEGER         reduce using rule 3 (declarations -> .)
    FLOAT           reduce using rule 3 (declarations -> .)
    STRING          reduce using rule 3 (declarations -> .)

    declarations                   shift and go to state 84

state 52

    (15) instruction -> expression . ;
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               shift and go to state 100
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    AND             shift and go to state 85
    OR              shift and go to state 96
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99


state 53

    (79) fundefs -> fundef fundefs .

    (               reduce using rule 79 (fundefs -> fundef fundefs .)
    PRINT           reduce using rule 79 (fundefs -> fundef fundefs .)
    IF              reduce using rule 79 (fundefs -> fundef fundefs .)
    WHILE           reduce using rule 79 (fundefs -> fundef fundefs .)
    REPEAT          reduce using rule 79 (fundefs -> fundef fundefs .)
    RETURN          reduce using rule 79 (fundefs -> fundef fundefs .)
    BREAK           reduce using rule 79 (fundefs -> fundef fundefs .)
    CONTINUE        reduce using rule 79 (fundefs -> fundef fundefs .)
    {               reduce using rule 79 (fundefs -> fundef fundefs .)
    ID              reduce using rule 79 (fundefs -> fundef fundefs .)
    INTEGER         reduce using rule 79 (fundefs -> fundef fundefs .)
    FLOAT           reduce using rule 79 (fundefs -> fundef fundefs .)
    STRING          reduce using rule 79 (fundefs -> fundef fundefs .)


state 54

    (81) fundef -> TYPE . id ( args_list_or_empty ) compound_instr
    (50) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 104

state 55

    (82) fundef -> id . id ( args_list_or_empty ) compound_instr
    (50) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 105

state 56

    (6) declaration -> error ; .

    TYPE            reduce using rule 6 (declaration -> error ; .)
    error           reduce using rule 6 (declaration -> error ; .)
    ID              reduce using rule 6 (declaration -> error ; .)
    (               reduce using rule 6 (declaration -> error ; .)
    PRINT           reduce using rule 6 (declaration -> error ; .)
    IF              reduce using rule 6 (declaration -> error ; .)
    WHILE           reduce using rule 6 (declaration -> error ; .)
    REPEAT          reduce using rule 6 (declaration -> error ; .)
    RETURN          reduce using rule 6 (declaration -> error ; .)
    BREAK           reduce using rule 6 (declaration -> error ; .)
    CONTINUE        reduce using rule 6 (declaration -> error ; .)
    {               reduce using rule 6 (declaration -> error ; .)
    INTEGER         reduce using rule 6 (declaration -> error ; .)
    FLOAT           reduce using rule 6 (declaration -> error ; .)
    STRING          reduce using rule 6 (declaration -> error ; .)
    PRIVATE         reduce using rule 6 (declaration -> error ; .)
    PROTECTED       reduce using rule 6 (declaration -> error ; .)
    PUBLIC          reduce using rule 6 (declaration -> error ; .)
    ;               reduce using rule 6 (declaration -> error ; .)


state 57

    (8) inits -> init .

    ;               reduce using rule 8 (inits -> init .)
    ,               reduce using rule 8 (inits -> init .)


state 58

    (4) declaration -> TYPE inits . ;
    (7) inits -> inits . , init

    ;               shift and go to state 106
    ,               shift and go to state 107


state 59

    (81) fundef -> TYPE id . ( args_list_or_empty ) compound_instr
    (9) init -> id . = expression

    (               shift and go to state 108
    =               shift and go to state 109


state 60

    (5) declaration -> id classinits . ;
    (10) classinits -> classinits . , classinit

    ;               shift and go to state 110
    ,               shift and go to state 111


state 61

    (11) classinits -> classinit .

    ;               reduce using rule 11 (classinits -> classinit .)
    ,               reduce using rule 11 (classinits -> classinit .)


state 62

    (82) fundef -> id id . ( args_list_or_empty ) compound_instr
    (12) classinit -> id .

    (               shift and go to state 112
    ;               reduce using rule 12 (classinit -> id .)
    ,               reduce using rule 12 (classinit -> id .)


state 63

    (92) classdef -> accessmodificator CLASS id EXTENDS id . classcontent
    (93) classcontent -> . { fielddefs ; methoddefs }

    {               shift and go to state 21

    classcontent                   shift and go to state 113

state 64

    (94) fielddefs -> fielddef . fielddefs
    (94) fielddefs -> . fielddef fielddefs
    (95) fielddefs -> .
    (96) fielddef -> . accessmodificator declaration
    (100) accessmodificator -> . PRIVATE
    (101) accessmodificator -> . PROTECTED
    (102) accessmodificator -> . PUBLIC

    ;               reduce using rule 95 (fielddefs -> .)
    PRIVATE         shift and go to state 3
    PROTECTED       shift and go to state 4
    PUBLIC          shift and go to state 7

    fielddef                       shift and go to state 64
    accessmodificator              shift and go to state 65
    fielddefs                      shift and go to state 114

state 65

    (96) fielddef -> accessmodificator . declaration
    (4) declaration -> . TYPE inits ;
    (5) declaration -> . id classinits ;
    (6) declaration -> . error ;
    (50) id -> . ID

    TYPE            shift and go to state 116
    error           shift and go to state 15
    ID              shift and go to state 11

    id                             shift and go to state 117
    declaration                    shift and go to state 115

state 66

    (93) classcontent -> { fielddefs . ; methoddefs }

    ;               shift and go to state 118


state 67

    (30) access -> id .
    (31) access -> id . . id

    (               reduce using rule 30 (access -> id .)
    +               reduce using rule 30 (access -> id .)
    -               reduce using rule 30 (access -> id .)
    *               reduce using rule 30 (access -> id .)
    /               reduce using rule 30 (access -> id .)
    %               reduce using rule 30 (access -> id .)
    |               reduce using rule 30 (access -> id .)
    &               reduce using rule 30 (access -> id .)
    ^               reduce using rule 30 (access -> id .)
    AND             reduce using rule 30 (access -> id .)
    OR              reduce using rule 30 (access -> id .)
    SHL             reduce using rule 30 (access -> id .)
    SHR             reduce using rule 30 (access -> id .)
    EQ              reduce using rule 30 (access -> id .)
    NEQ             reduce using rule 30 (access -> id .)
    >               reduce using rule 30 (access -> id .)
    <               reduce using rule 30 (access -> id .)
    LE              reduce using rule 30 (access -> id .)
    GE              reduce using rule 30 (access -> id .)
    ;               reduce using rule 30 (access -> id .)
    )               reduce using rule 30 (access -> id .)
    ,               reduce using rule 30 (access -> id .)
    .               shift and go to state 75


state 68

    (52) expression -> access .
    (73) expression -> access . ( expr_list_or_empty )
    (74) expression -> access . ( error )

    +               reduce using rule 52 (expression -> access .)
    -               reduce using rule 52 (expression -> access .)
    *               reduce using rule 52 (expression -> access .)
    /               reduce using rule 52 (expression -> access .)
    %               reduce using rule 52 (expression -> access .)
    |               reduce using rule 52 (expression -> access .)
    &               reduce using rule 52 (expression -> access .)
    ^               reduce using rule 52 (expression -> access .)
    AND             reduce using rule 52 (expression -> access .)
    OR              reduce using rule 52 (expression -> access .)
    SHL             reduce using rule 52 (expression -> access .)
    SHR             reduce using rule 52 (expression -> access .)
    EQ              reduce using rule 52 (expression -> access .)
    NEQ             reduce using rule 52 (expression -> access .)
    >               reduce using rule 52 (expression -> access .)
    <               reduce using rule 52 (expression -> access .)
    LE              reduce using rule 52 (expression -> access .)
    GE              reduce using rule 52 (expression -> access .)
    ;               reduce using rule 52 (expression -> access .)
    )               reduce using rule 52 (expression -> access .)
    ,               reduce using rule 52 (expression -> access .)
    (               shift and go to state 76


state 69

    (39) return_instr -> RETURN expression . ;
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               shift and go to state 119
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    AND             shift and go to state 85
    OR              shift and go to state 96
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99


state 70

    (32) choice_instr -> IF ( . condition ) instruction
    (33) choice_instr -> IF ( . condition ) instruction ELSE instruction
    (34) choice_instr -> IF ( . error ) instruction
    (35) choice_instr -> IF ( . error ) instruction ELSE instruction
    (43) condition -> . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    error           shift and go to state 121
    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    float                          shift and go to state 24
    const                          shift and go to state 34
    string                         shift and go to state 40
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 122
    id                             shift and go to state 67
    condition                      shift and go to state 120

state 71

    (27) print_instr -> PRINT error . ;

    ;               shift and go to state 123


state 72

    (26) print_instr -> PRINT expression . ;
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               shift and go to state 124
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    AND             shift and go to state 85
    OR              shift and go to state 96
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99


state 73

    (36) while_instr -> WHILE ( . condition ) instruction
    (37) while_instr -> WHILE ( . error ) instruction
    (43) condition -> . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    error           shift and go to state 126
    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    float                          shift and go to state 24
    const                          shift and go to state 34
    string                         shift and go to state 40
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 122
    id                             shift and go to state 67
    condition                      shift and go to state 125

state 74

    (28) labeled_instr -> id : . instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 127
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 75

    (31) access -> id . . id
    (50) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 128

state 76

    (73) expression -> access ( . expr_list_or_empty )
    (74) expression -> access ( . error )
    (75) expr_list_or_empty -> . expr_list
    (76) expr_list_or_empty -> .
    (77) expr_list -> . expr_list , expression
    (78) expr_list -> . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    error           shift and go to state 131
    )               reduce using rule 76 (expr_list_or_empty -> .)
    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    expr_list_or_empty             shift and go to state 130
    string                         shift and go to state 40
    expr_list                      shift and go to state 129
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 132
    id                             shift and go to state 67
    const                          shift and go to state 34

state 77

    (29) assignment -> access = . expression ;
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 133
    id                             shift and go to state 67

state 78

    (38) repeat_instr -> REPEAT instructions . UNTIL condition ;
    (13) instructions -> instructions . instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    UNTIL           shift and go to state 134
    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 79
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 79

    (13) instructions -> instructions instruction .

    }               reduce using rule 13 (instructions -> instructions instruction .)
    (               reduce using rule 13 (instructions -> instructions instruction .)
    PRINT           reduce using rule 13 (instructions -> instructions instruction .)
    IF              reduce using rule 13 (instructions -> instructions instruction .)
    WHILE           reduce using rule 13 (instructions -> instructions instruction .)
    REPEAT          reduce using rule 13 (instructions -> instructions instruction .)
    RETURN          reduce using rule 13 (instructions -> instructions instruction .)
    BREAK           reduce using rule 13 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 13 (instructions -> instructions instruction .)
    {               reduce using rule 13 (instructions -> instructions instruction .)
    ID              reduce using rule 13 (instructions -> instructions instruction .)
    INTEGER         reduce using rule 13 (instructions -> instructions instruction .)
    FLOAT           reduce using rule 13 (instructions -> instructions instruction .)
    STRING          reduce using rule 13 (instructions -> instructions instruction .)
    $end            reduce using rule 13 (instructions -> instructions instruction .)
    UNTIL           reduce using rule 13 (instructions -> instructions instruction .)


state 80

    (41) break_instr -> BREAK ; .

    (               reduce using rule 41 (break_instr -> BREAK ; .)
    PRINT           reduce using rule 41 (break_instr -> BREAK ; .)
    IF              reduce using rule 41 (break_instr -> BREAK ; .)
    WHILE           reduce using rule 41 (break_instr -> BREAK ; .)
    REPEAT          reduce using rule 41 (break_instr -> BREAK ; .)
    RETURN          reduce using rule 41 (break_instr -> BREAK ; .)
    BREAK           reduce using rule 41 (break_instr -> BREAK ; .)
    CONTINUE        reduce using rule 41 (break_instr -> BREAK ; .)
    {               reduce using rule 41 (break_instr -> BREAK ; .)
    ID              reduce using rule 41 (break_instr -> BREAK ; .)
    INTEGER         reduce using rule 41 (break_instr -> BREAK ; .)
    FLOAT           reduce using rule 41 (break_instr -> BREAK ; .)
    STRING          reduce using rule 41 (break_instr -> BREAK ; .)
    $end            reduce using rule 41 (break_instr -> BREAK ; .)
    UNTIL           reduce using rule 41 (break_instr -> BREAK ; .)
    }               reduce using rule 41 (break_instr -> BREAK ; .)
    ELSE            reduce using rule 41 (break_instr -> BREAK ; .)


state 81

    (40) continue_instr -> CONTINUE ; .

    }               reduce using rule 40 (continue_instr -> CONTINUE ; .)
    (               reduce using rule 40 (continue_instr -> CONTINUE ; .)
    PRINT           reduce using rule 40 (continue_instr -> CONTINUE ; .)
    IF              reduce using rule 40 (continue_instr -> CONTINUE ; .)
    WHILE           reduce using rule 40 (continue_instr -> CONTINUE ; .)
    REPEAT          reduce using rule 40 (continue_instr -> CONTINUE ; .)
    RETURN          reduce using rule 40 (continue_instr -> CONTINUE ; .)
    BREAK           reduce using rule 40 (continue_instr -> CONTINUE ; .)
    CONTINUE        reduce using rule 40 (continue_instr -> CONTINUE ; .)
    {               reduce using rule 40 (continue_instr -> CONTINUE ; .)
    ID              reduce using rule 40 (continue_instr -> CONTINUE ; .)
    INTEGER         reduce using rule 40 (continue_instr -> CONTINUE ; .)
    FLOAT           reduce using rule 40 (continue_instr -> CONTINUE ; .)
    STRING          reduce using rule 40 (continue_instr -> CONTINUE ; .)
    $end            reduce using rule 40 (continue_instr -> CONTINUE ; .)
    UNTIL           reduce using rule 40 (continue_instr -> CONTINUE ; .)
    ELSE            reduce using rule 40 (continue_instr -> CONTINUE ; .)


state 82

    (72) expression -> ( error . )

    )               shift and go to state 135


state 83

    (71) expression -> ( expression . )
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    )               shift and go to state 136
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    AND             shift and go to state 85
    OR              shift and go to state 96
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99


state 84

    (42) compound_instr -> { declarations . instructions }
    (2) declarations -> declarations . declaration
    (13) instructions -> . instructions instruction
    (14) instructions -> . instruction
    (4) declaration -> . TYPE inits ;
    (5) declaration -> . id classinits ;
    (6) declaration -> . error ;
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (50) id -> . ID
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    TYPE            shift and go to state 116
    error           shift and go to state 15
    ID              shift and go to state 11
    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 137
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    declaration                    shift and go to state 16
    integer                        shift and go to state 28
    instructions                   shift and go to state 138
    break_instr                    shift and go to state 46
    instruction                    shift and go to state 22
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 85

    (61) expression -> expression AND . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 139
    id                             shift and go to state 67

state 86

    (64) expression -> expression SHR . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 140
    id                             shift and go to state 67

state 87

    (69) expression -> expression LE . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 141
    id                             shift and go to state 67

state 88

    (57) expression -> expression % . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 142
    id                             shift and go to state 67

state 89

    (59) expression -> expression & . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 143
    id                             shift and go to state 67

state 90

    (68) expression -> expression < . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 144
    id                             shift and go to state 67

state 91

    (63) expression -> expression SHL . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 145
    id                             shift and go to state 67

state 92

    (53) expression -> expression + . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 146
    id                             shift and go to state 67

state 93

    (55) expression -> expression * . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 147
    id                             shift and go to state 67

state 94

    (54) expression -> expression - . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 148
    id                             shift and go to state 67

state 95

    (56) expression -> expression / . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 149
    id                             shift and go to state 67

state 96

    (62) expression -> expression OR . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 150
    id                             shift and go to state 67

state 97

    (65) expression -> expression EQ . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 151
    id                             shift and go to state 67

state 98

    (67) expression -> expression > . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 152
    id                             shift and go to state 67

state 99

    (70) expression -> expression GE . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 153
    id                             shift and go to state 67

state 100

    (15) instruction -> expression ; .

    UNTIL           reduce using rule 15 (instruction -> expression ; .)
    (               reduce using rule 15 (instruction -> expression ; .)
    PRINT           reduce using rule 15 (instruction -> expression ; .)
    IF              reduce using rule 15 (instruction -> expression ; .)
    WHILE           reduce using rule 15 (instruction -> expression ; .)
    REPEAT          reduce using rule 15 (instruction -> expression ; .)
    RETURN          reduce using rule 15 (instruction -> expression ; .)
    BREAK           reduce using rule 15 (instruction -> expression ; .)
    CONTINUE        reduce using rule 15 (instruction -> expression ; .)
    {               reduce using rule 15 (instruction -> expression ; .)
    ID              reduce using rule 15 (instruction -> expression ; .)
    INTEGER         reduce using rule 15 (instruction -> expression ; .)
    FLOAT           reduce using rule 15 (instruction -> expression ; .)
    STRING          reduce using rule 15 (instruction -> expression ; .)
    $end            reduce using rule 15 (instruction -> expression ; .)
    }               reduce using rule 15 (instruction -> expression ; .)
    ELSE            reduce using rule 15 (instruction -> expression ; .)


state 101

    (66) expression -> expression NEQ . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 154
    id                             shift and go to state 67

state 102

    (58) expression -> expression | . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 155
    id                             shift and go to state 67

state 103

    (60) expression -> expression ^ . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 156
    id                             shift and go to state 67

state 104

    (81) fundef -> TYPE id . ( args_list_or_empty ) compound_instr

    (               shift and go to state 108


state 105

    (82) fundef -> id id . ( args_list_or_empty ) compound_instr

    (               shift and go to state 112


state 106

    (4) declaration -> TYPE inits ; .

    TYPE            reduce using rule 4 (declaration -> TYPE inits ; .)
    error           reduce using rule 4 (declaration -> TYPE inits ; .)
    ID              reduce using rule 4 (declaration -> TYPE inits ; .)
    (               reduce using rule 4 (declaration -> TYPE inits ; .)
    PRINT           reduce using rule 4 (declaration -> TYPE inits ; .)
    IF              reduce using rule 4 (declaration -> TYPE inits ; .)
    WHILE           reduce using rule 4 (declaration -> TYPE inits ; .)
    REPEAT          reduce using rule 4 (declaration -> TYPE inits ; .)
    RETURN          reduce using rule 4 (declaration -> TYPE inits ; .)
    BREAK           reduce using rule 4 (declaration -> TYPE inits ; .)
    CONTINUE        reduce using rule 4 (declaration -> TYPE inits ; .)
    {               reduce using rule 4 (declaration -> TYPE inits ; .)
    INTEGER         reduce using rule 4 (declaration -> TYPE inits ; .)
    FLOAT           reduce using rule 4 (declaration -> TYPE inits ; .)
    STRING          reduce using rule 4 (declaration -> TYPE inits ; .)
    PRIVATE         reduce using rule 4 (declaration -> TYPE inits ; .)
    PROTECTED       reduce using rule 4 (declaration -> TYPE inits ; .)
    PUBLIC          reduce using rule 4 (declaration -> TYPE inits ; .)
    ;               reduce using rule 4 (declaration -> TYPE inits ; .)


state 107

    (7) inits -> inits , . init
    (9) init -> . id = expression
    (50) id -> . ID

    ID              shift and go to state 11

    init                           shift and go to state 157
    id                             shift and go to state 158

state 108

    (81) fundef -> TYPE id ( . args_list_or_empty ) compound_instr
    (83) args_list_or_empty -> . args_list
    (84) args_list_or_empty -> .
    (85) args_list -> . args_list , arg
    (86) args_list -> . arg
    (87) arg -> . TYPE id
    (88) arg -> . id id
    (50) id -> . ID

    )               reduce using rule 84 (args_list_or_empty -> .)
    TYPE            shift and go to state 162
    ID              shift and go to state 11

    args_list_or_empty             shift and go to state 160
    arg                            shift and go to state 161
    id                             shift and go to state 163
    args_list                      shift and go to state 159

state 109

    (9) init -> id = . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 164
    id                             shift and go to state 67
    string                         shift and go to state 40

state 110

    (5) declaration -> id classinits ; .

    TYPE            reduce using rule 5 (declaration -> id classinits ; .)
    error           reduce using rule 5 (declaration -> id classinits ; .)
    ID              reduce using rule 5 (declaration -> id classinits ; .)
    (               reduce using rule 5 (declaration -> id classinits ; .)
    PRINT           reduce using rule 5 (declaration -> id classinits ; .)
    IF              reduce using rule 5 (declaration -> id classinits ; .)
    WHILE           reduce using rule 5 (declaration -> id classinits ; .)
    REPEAT          reduce using rule 5 (declaration -> id classinits ; .)
    RETURN          reduce using rule 5 (declaration -> id classinits ; .)
    BREAK           reduce using rule 5 (declaration -> id classinits ; .)
    CONTINUE        reduce using rule 5 (declaration -> id classinits ; .)
    {               reduce using rule 5 (declaration -> id classinits ; .)
    INTEGER         reduce using rule 5 (declaration -> id classinits ; .)
    FLOAT           reduce using rule 5 (declaration -> id classinits ; .)
    STRING          reduce using rule 5 (declaration -> id classinits ; .)
    PRIVATE         reduce using rule 5 (declaration -> id classinits ; .)
    PROTECTED       reduce using rule 5 (declaration -> id classinits ; .)
    PUBLIC          reduce using rule 5 (declaration -> id classinits ; .)
    ;               reduce using rule 5 (declaration -> id classinits ; .)


state 111

    (10) classinits -> classinits , . classinit
    (12) classinit -> . id
    (50) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 165
    classinit                      shift and go to state 166

state 112

    (82) fundef -> id id ( . args_list_or_empty ) compound_instr
    (83) args_list_or_empty -> . args_list
    (84) args_list_or_empty -> .
    (85) args_list -> . args_list , arg
    (86) args_list -> . arg
    (87) arg -> . TYPE id
    (88) arg -> . id id
    (50) id -> . ID

    )               reduce using rule 84 (args_list_or_empty -> .)
    TYPE            shift and go to state 162
    ID              shift and go to state 11

    args_list_or_empty             shift and go to state 167
    arg                            shift and go to state 161
    id                             shift and go to state 163
    args_list                      shift and go to state 159

state 113

    (92) classdef -> accessmodificator CLASS id EXTENDS id classcontent .

    PRIVATE         reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    PROTECTED       reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    PUBLIC          reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    TYPE            reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    error           reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    ID              reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    (               reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    PRINT           reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    IF              reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    WHILE           reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    REPEAT          reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    RETURN          reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    BREAK           reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    CONTINUE        reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    {               reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    INTEGER         reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    FLOAT           reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)
    STRING          reduce using rule 92 (classdef -> accessmodificator CLASS id EXTENDS id classcontent .)


state 114

    (94) fielddefs -> fielddef fielddefs .

    ;               reduce using rule 94 (fielddefs -> fielddef fielddefs .)


state 115

    (96) fielddef -> accessmodificator declaration .

    PRIVATE         reduce using rule 96 (fielddef -> accessmodificator declaration .)
    PROTECTED       reduce using rule 96 (fielddef -> accessmodificator declaration .)
    PUBLIC          reduce using rule 96 (fielddef -> accessmodificator declaration .)
    ;               reduce using rule 96 (fielddef -> accessmodificator declaration .)


state 116

    (4) declaration -> TYPE . inits ;
    (7) inits -> . inits , init
    (8) inits -> . init
    (9) init -> . id = expression
    (50) id -> . ID

    ID              shift and go to state 11

    init                           shift and go to state 57
    inits                          shift and go to state 58
    id                             shift and go to state 158

state 117

    (5) declaration -> id . classinits ;
    (10) classinits -> . classinits , classinit
    (11) classinits -> . classinit
    (12) classinit -> . id
    (50) id -> . ID

    ID              shift and go to state 11

    classinits                     shift and go to state 60
    id                             shift and go to state 165
    classinit                      shift and go to state 61

state 118

    (93) classcontent -> { fielddefs ; . methoddefs }
    (97) methoddefs -> . methoddef methoddefs
    (98) methoddefs -> .
    (99) methoddef -> . accessmodificator fundef
    (100) accessmodificator -> . PRIVATE
    (101) accessmodificator -> . PROTECTED
    (102) accessmodificator -> . PUBLIC

    }               reduce using rule 98 (methoddefs -> .)
    PRIVATE         shift and go to state 3
    PROTECTED       shift and go to state 4
    PUBLIC          shift and go to state 7

    accessmodificator              shift and go to state 170
    methoddef                      shift and go to state 168
    methoddefs                     shift and go to state 169

state 119

    (39) return_instr -> RETURN expression ; .

    (               reduce using rule 39 (return_instr -> RETURN expression ; .)
    PRINT           reduce using rule 39 (return_instr -> RETURN expression ; .)
    IF              reduce using rule 39 (return_instr -> RETURN expression ; .)
    WHILE           reduce using rule 39 (return_instr -> RETURN expression ; .)
    REPEAT          reduce using rule 39 (return_instr -> RETURN expression ; .)
    RETURN          reduce using rule 39 (return_instr -> RETURN expression ; .)
    BREAK           reduce using rule 39 (return_instr -> RETURN expression ; .)
    CONTINUE        reduce using rule 39 (return_instr -> RETURN expression ; .)
    {               reduce using rule 39 (return_instr -> RETURN expression ; .)
    ID              reduce using rule 39 (return_instr -> RETURN expression ; .)
    INTEGER         reduce using rule 39 (return_instr -> RETURN expression ; .)
    FLOAT           reduce using rule 39 (return_instr -> RETURN expression ; .)
    STRING          reduce using rule 39 (return_instr -> RETURN expression ; .)
    $end            reduce using rule 39 (return_instr -> RETURN expression ; .)
    UNTIL           reduce using rule 39 (return_instr -> RETURN expression ; .)
    }               reduce using rule 39 (return_instr -> RETURN expression ; .)
    ELSE            reduce using rule 39 (return_instr -> RETURN expression ; .)


state 120

    (32) choice_instr -> IF ( condition . ) instruction
    (33) choice_instr -> IF ( condition . ) instruction ELSE instruction

    )               shift and go to state 171


state 121

    (34) choice_instr -> IF ( error . ) instruction
    (35) choice_instr -> IF ( error . ) instruction ELSE instruction

    )               shift and go to state 172


state 122

    (43) condition -> expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    )               reduce using rule 43 (condition -> expression .)
    ;               reduce using rule 43 (condition -> expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    AND             shift and go to state 85
    OR              shift and go to state 96
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99


state 123

    (27) print_instr -> PRINT error ; .

    (               reduce using rule 27 (print_instr -> PRINT error ; .)
    PRINT           reduce using rule 27 (print_instr -> PRINT error ; .)
    IF              reduce using rule 27 (print_instr -> PRINT error ; .)
    WHILE           reduce using rule 27 (print_instr -> PRINT error ; .)
    REPEAT          reduce using rule 27 (print_instr -> PRINT error ; .)
    RETURN          reduce using rule 27 (print_instr -> PRINT error ; .)
    BREAK           reduce using rule 27 (print_instr -> PRINT error ; .)
    CONTINUE        reduce using rule 27 (print_instr -> PRINT error ; .)
    {               reduce using rule 27 (print_instr -> PRINT error ; .)
    ID              reduce using rule 27 (print_instr -> PRINT error ; .)
    INTEGER         reduce using rule 27 (print_instr -> PRINT error ; .)
    FLOAT           reduce using rule 27 (print_instr -> PRINT error ; .)
    STRING          reduce using rule 27 (print_instr -> PRINT error ; .)
    $end            reduce using rule 27 (print_instr -> PRINT error ; .)
    UNTIL           reduce using rule 27 (print_instr -> PRINT error ; .)
    }               reduce using rule 27 (print_instr -> PRINT error ; .)
    ELSE            reduce using rule 27 (print_instr -> PRINT error ; .)


state 124

    (26) print_instr -> PRINT expression ; .

    (               reduce using rule 26 (print_instr -> PRINT expression ; .)
    PRINT           reduce using rule 26 (print_instr -> PRINT expression ; .)
    IF              reduce using rule 26 (print_instr -> PRINT expression ; .)
    WHILE           reduce using rule 26 (print_instr -> PRINT expression ; .)
    REPEAT          reduce using rule 26 (print_instr -> PRINT expression ; .)
    RETURN          reduce using rule 26 (print_instr -> PRINT expression ; .)
    BREAK           reduce using rule 26 (print_instr -> PRINT expression ; .)
    CONTINUE        reduce using rule 26 (print_instr -> PRINT expression ; .)
    {               reduce using rule 26 (print_instr -> PRINT expression ; .)
    ID              reduce using rule 26 (print_instr -> PRINT expression ; .)
    INTEGER         reduce using rule 26 (print_instr -> PRINT expression ; .)
    FLOAT           reduce using rule 26 (print_instr -> PRINT expression ; .)
    STRING          reduce using rule 26 (print_instr -> PRINT expression ; .)
    $end            reduce using rule 26 (print_instr -> PRINT expression ; .)
    UNTIL           reduce using rule 26 (print_instr -> PRINT expression ; .)
    }               reduce using rule 26 (print_instr -> PRINT expression ; .)
    ELSE            reduce using rule 26 (print_instr -> PRINT expression ; .)


state 125

    (36) while_instr -> WHILE ( condition . ) instruction

    )               shift and go to state 173


state 126

    (37) while_instr -> WHILE ( error . ) instruction

    )               shift and go to state 174


state 127

    (28) labeled_instr -> id : instruction .

    (               reduce using rule 28 (labeled_instr -> id : instruction .)
    PRINT           reduce using rule 28 (labeled_instr -> id : instruction .)
    IF              reduce using rule 28 (labeled_instr -> id : instruction .)
    WHILE           reduce using rule 28 (labeled_instr -> id : instruction .)
    REPEAT          reduce using rule 28 (labeled_instr -> id : instruction .)
    RETURN          reduce using rule 28 (labeled_instr -> id : instruction .)
    BREAK           reduce using rule 28 (labeled_instr -> id : instruction .)
    CONTINUE        reduce using rule 28 (labeled_instr -> id : instruction .)
    {               reduce using rule 28 (labeled_instr -> id : instruction .)
    ID              reduce using rule 28 (labeled_instr -> id : instruction .)
    INTEGER         reduce using rule 28 (labeled_instr -> id : instruction .)
    FLOAT           reduce using rule 28 (labeled_instr -> id : instruction .)
    STRING          reduce using rule 28 (labeled_instr -> id : instruction .)
    $end            reduce using rule 28 (labeled_instr -> id : instruction .)
    UNTIL           reduce using rule 28 (labeled_instr -> id : instruction .)
    }               reduce using rule 28 (labeled_instr -> id : instruction .)
    ELSE            reduce using rule 28 (labeled_instr -> id : instruction .)


state 128

    (31) access -> id . id .

    (               reduce using rule 31 (access -> id . id .)
    =               reduce using rule 31 (access -> id . id .)
    ;               reduce using rule 31 (access -> id . id .)
    +               reduce using rule 31 (access -> id . id .)
    -               reduce using rule 31 (access -> id . id .)
    *               reduce using rule 31 (access -> id . id .)
    /               reduce using rule 31 (access -> id . id .)
    %               reduce using rule 31 (access -> id . id .)
    |               reduce using rule 31 (access -> id . id .)
    &               reduce using rule 31 (access -> id . id .)
    ^               reduce using rule 31 (access -> id . id .)
    AND             reduce using rule 31 (access -> id . id .)
    OR              reduce using rule 31 (access -> id . id .)
    SHL             reduce using rule 31 (access -> id . id .)
    SHR             reduce using rule 31 (access -> id . id .)
    EQ              reduce using rule 31 (access -> id . id .)
    NEQ             reduce using rule 31 (access -> id . id .)
    >               reduce using rule 31 (access -> id . id .)
    <               reduce using rule 31 (access -> id . id .)
    LE              reduce using rule 31 (access -> id . id .)
    GE              reduce using rule 31 (access -> id . id .)
    )               reduce using rule 31 (access -> id . id .)
    ,               reduce using rule 31 (access -> id . id .)


state 129

    (75) expr_list_or_empty -> expr_list .
    (77) expr_list -> expr_list . , expression

    )               reduce using rule 75 (expr_list_or_empty -> expr_list .)
    ,               shift and go to state 175


state 130

    (73) expression -> access ( expr_list_or_empty . )

    )               shift and go to state 176


state 131

    (74) expression -> access ( error . )

    )               shift and go to state 177


state 132

    (78) expr_list -> expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ,               reduce using rule 78 (expr_list -> expression .)
    )               reduce using rule 78 (expr_list -> expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    AND             shift and go to state 85
    OR              shift and go to state 96
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99


state 133

    (29) assignment -> access = expression . ;
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               shift and go to state 178
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    AND             shift and go to state 85
    OR              shift and go to state 96
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99


state 134

    (38) repeat_instr -> REPEAT instructions UNTIL . condition ;
    (43) condition -> . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    const                          shift and go to state 34
    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 122
    id                             shift and go to state 67
    condition                      shift and go to state 179

state 135

    (72) expression -> ( error ) .

    +               reduce using rule 72 (expression -> ( error ) .)
    -               reduce using rule 72 (expression -> ( error ) .)
    *               reduce using rule 72 (expression -> ( error ) .)
    /               reduce using rule 72 (expression -> ( error ) .)
    %               reduce using rule 72 (expression -> ( error ) .)
    |               reduce using rule 72 (expression -> ( error ) .)
    &               reduce using rule 72 (expression -> ( error ) .)
    ^               reduce using rule 72 (expression -> ( error ) .)
    AND             reduce using rule 72 (expression -> ( error ) .)
    OR              reduce using rule 72 (expression -> ( error ) .)
    SHL             reduce using rule 72 (expression -> ( error ) .)
    SHR             reduce using rule 72 (expression -> ( error ) .)
    EQ              reduce using rule 72 (expression -> ( error ) .)
    NEQ             reduce using rule 72 (expression -> ( error ) .)
    >               reduce using rule 72 (expression -> ( error ) .)
    <               reduce using rule 72 (expression -> ( error ) .)
    LE              reduce using rule 72 (expression -> ( error ) .)
    GE              reduce using rule 72 (expression -> ( error ) .)
    ;               reduce using rule 72 (expression -> ( error ) .)
    )               reduce using rule 72 (expression -> ( error ) .)
    ,               reduce using rule 72 (expression -> ( error ) .)


state 136

    (71) expression -> ( expression ) .

    +               reduce using rule 71 (expression -> ( expression ) .)
    -               reduce using rule 71 (expression -> ( expression ) .)
    *               reduce using rule 71 (expression -> ( expression ) .)
    /               reduce using rule 71 (expression -> ( expression ) .)
    %               reduce using rule 71 (expression -> ( expression ) .)
    |               reduce using rule 71 (expression -> ( expression ) .)
    &               reduce using rule 71 (expression -> ( expression ) .)
    ^               reduce using rule 71 (expression -> ( expression ) .)
    AND             reduce using rule 71 (expression -> ( expression ) .)
    OR              reduce using rule 71 (expression -> ( expression ) .)
    SHL             reduce using rule 71 (expression -> ( expression ) .)
    SHR             reduce using rule 71 (expression -> ( expression ) .)
    EQ              reduce using rule 71 (expression -> ( expression ) .)
    NEQ             reduce using rule 71 (expression -> ( expression ) .)
    >               reduce using rule 71 (expression -> ( expression ) .)
    <               reduce using rule 71 (expression -> ( expression ) .)
    LE              reduce using rule 71 (expression -> ( expression ) .)
    GE              reduce using rule 71 (expression -> ( expression ) .)
    ;               reduce using rule 71 (expression -> ( expression ) .)
    )               reduce using rule 71 (expression -> ( expression ) .)
    ,               reduce using rule 71 (expression -> ( expression ) .)


state 137

    (5) declaration -> id . classinits ;
    (28) labeled_instr -> id . : instruction
    (30) access -> id .
    (31) access -> id . . id
    (10) classinits -> . classinits , classinit
    (11) classinits -> . classinit
    (12) classinit -> . id
    (50) id -> . ID

    :               shift and go to state 74
    (               reduce using rule 30 (access -> id .)
    =               reduce using rule 30 (access -> id .)
    ;               reduce using rule 30 (access -> id .)
    +               reduce using rule 30 (access -> id .)
    -               reduce using rule 30 (access -> id .)
    *               reduce using rule 30 (access -> id .)
    /               reduce using rule 30 (access -> id .)
    %               reduce using rule 30 (access -> id .)
    |               reduce using rule 30 (access -> id .)
    &               reduce using rule 30 (access -> id .)
    ^               reduce using rule 30 (access -> id .)
    AND             reduce using rule 30 (access -> id .)
    OR              reduce using rule 30 (access -> id .)
    SHL             reduce using rule 30 (access -> id .)
    SHR             reduce using rule 30 (access -> id .)
    EQ              reduce using rule 30 (access -> id .)
    NEQ             reduce using rule 30 (access -> id .)
    >               reduce using rule 30 (access -> id .)
    <               reduce using rule 30 (access -> id .)
    LE              reduce using rule 30 (access -> id .)
    GE              reduce using rule 30 (access -> id .)
    .               shift and go to state 75
    ID              shift and go to state 11

    classinits                     shift and go to state 60
    id                             shift and go to state 165
    classinit                      shift and go to state 61

state 138

    (42) compound_instr -> { declarations instructions . }
    (13) instructions -> instructions . instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    }               shift and go to state 180
    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    break_instr                    shift and go to state 46
    instruction                    shift and go to state 79
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 139

    (61) expression -> expression AND expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    AND             reduce using rule 61 (expression -> expression AND expression .)
    OR              reduce using rule 61 (expression -> expression AND expression .)
    ;               reduce using rule 61 (expression -> expression AND expression .)
    )               reduce using rule 61 (expression -> expression AND expression .)
    ,               reduce using rule 61 (expression -> expression AND expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99

  ! +               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! -               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! *               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! /               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! %               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! |               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! &               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! ^               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! SHL             [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! SHR             [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! >               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! <               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]


state 140

    (64) expression -> expression SHR expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 64 (expression -> expression SHR expression .)
    &               reduce using rule 64 (expression -> expression SHR expression .)
    ^               reduce using rule 64 (expression -> expression SHR expression .)
    AND             reduce using rule 64 (expression -> expression SHR expression .)
    OR              reduce using rule 64 (expression -> expression SHR expression .)
    SHL             reduce using rule 64 (expression -> expression SHR expression .)
    SHR             reduce using rule 64 (expression -> expression SHR expression .)
    EQ              reduce using rule 64 (expression -> expression SHR expression .)
    NEQ             reduce using rule 64 (expression -> expression SHR expression .)
    >               reduce using rule 64 (expression -> expression SHR expression .)
    <               reduce using rule 64 (expression -> expression SHR expression .)
    LE              reduce using rule 64 (expression -> expression SHR expression .)
    GE              reduce using rule 64 (expression -> expression SHR expression .)
    ;               reduce using rule 64 (expression -> expression SHR expression .)
    )               reduce using rule 64 (expression -> expression SHR expression .)
    ,               reduce using rule 64 (expression -> expression SHR expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88

  ! +               [ reduce using rule 64 (expression -> expression SHR expression .) ]
  ! -               [ reduce using rule 64 (expression -> expression SHR expression .) ]
  ! *               [ reduce using rule 64 (expression -> expression SHR expression .) ]
  ! /               [ reduce using rule 64 (expression -> expression SHR expression .) ]
  ! %               [ reduce using rule 64 (expression -> expression SHR expression .) ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! SHL             [ shift and go to state 91 ]
  ! SHR             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 141

    (69) expression -> expression LE expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 69 (expression -> expression LE expression .)
    &               reduce using rule 69 (expression -> expression LE expression .)
    ^               reduce using rule 69 (expression -> expression LE expression .)
    AND             reduce using rule 69 (expression -> expression LE expression .)
    OR              reduce using rule 69 (expression -> expression LE expression .)
    EQ              reduce using rule 69 (expression -> expression LE expression .)
    NEQ             reduce using rule 69 (expression -> expression LE expression .)
    >               reduce using rule 69 (expression -> expression LE expression .)
    <               reduce using rule 69 (expression -> expression LE expression .)
    LE              reduce using rule 69 (expression -> expression LE expression .)
    GE              reduce using rule 69 (expression -> expression LE expression .)
    ;               reduce using rule 69 (expression -> expression LE expression .)
    )               reduce using rule 69 (expression -> expression LE expression .)
    ,               reduce using rule 69 (expression -> expression LE expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    SHL             shift and go to state 91
    SHR             shift and go to state 86

  ! +               [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! -               [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! *               [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! /               [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! %               [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! SHL             [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! SHR             [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 142

    (57) expression -> expression % expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    +               reduce using rule 57 (expression -> expression % expression .)
    -               reduce using rule 57 (expression -> expression % expression .)
    *               reduce using rule 57 (expression -> expression % expression .)
    /               reduce using rule 57 (expression -> expression % expression .)
    %               reduce using rule 57 (expression -> expression % expression .)
    |               reduce using rule 57 (expression -> expression % expression .)
    &               reduce using rule 57 (expression -> expression % expression .)
    ^               reduce using rule 57 (expression -> expression % expression .)
    AND             reduce using rule 57 (expression -> expression % expression .)
    OR              reduce using rule 57 (expression -> expression % expression .)
    SHL             reduce using rule 57 (expression -> expression % expression .)
    SHR             reduce using rule 57 (expression -> expression % expression .)
    EQ              reduce using rule 57 (expression -> expression % expression .)
    NEQ             reduce using rule 57 (expression -> expression % expression .)
    >               reduce using rule 57 (expression -> expression % expression .)
    <               reduce using rule 57 (expression -> expression % expression .)
    LE              reduce using rule 57 (expression -> expression % expression .)
    GE              reduce using rule 57 (expression -> expression % expression .)
    ;               reduce using rule 57 (expression -> expression % expression .)
    )               reduce using rule 57 (expression -> expression % expression .)
    ,               reduce using rule 57 (expression -> expression % expression .)

  ! +               [ shift and go to state 92 ]
  ! -               [ shift and go to state 94 ]
  ! *               [ shift and go to state 93 ]
  ! /               [ shift and go to state 95 ]
  ! %               [ shift and go to state 88 ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! SHL             [ shift and go to state 91 ]
  ! SHR             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 143

    (59) expression -> expression & expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 59 (expression -> expression & expression .)
    &               reduce using rule 59 (expression -> expression & expression .)
    ^               reduce using rule 59 (expression -> expression & expression .)
    AND             reduce using rule 59 (expression -> expression & expression .)
    OR              reduce using rule 59 (expression -> expression & expression .)
    ;               reduce using rule 59 (expression -> expression & expression .)
    )               reduce using rule 59 (expression -> expression & expression .)
    ,               reduce using rule 59 (expression -> expression & expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99

  ! +               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! -               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! *               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! /               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! %               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! SHL             [ reduce using rule 59 (expression -> expression & expression .) ]
  ! SHR             [ reduce using rule 59 (expression -> expression & expression .) ]
  ! EQ              [ reduce using rule 59 (expression -> expression & expression .) ]
  ! NEQ             [ reduce using rule 59 (expression -> expression & expression .) ]
  ! >               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! <               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! LE              [ reduce using rule 59 (expression -> expression & expression .) ]
  ! GE              [ reduce using rule 59 (expression -> expression & expression .) ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]


state 144

    (68) expression -> expression < expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 68 (expression -> expression < expression .)
    &               reduce using rule 68 (expression -> expression < expression .)
    ^               reduce using rule 68 (expression -> expression < expression .)
    AND             reduce using rule 68 (expression -> expression < expression .)
    OR              reduce using rule 68 (expression -> expression < expression .)
    EQ              reduce using rule 68 (expression -> expression < expression .)
    NEQ             reduce using rule 68 (expression -> expression < expression .)
    >               reduce using rule 68 (expression -> expression < expression .)
    <               reduce using rule 68 (expression -> expression < expression .)
    LE              reduce using rule 68 (expression -> expression < expression .)
    GE              reduce using rule 68 (expression -> expression < expression .)
    ;               reduce using rule 68 (expression -> expression < expression .)
    )               reduce using rule 68 (expression -> expression < expression .)
    ,               reduce using rule 68 (expression -> expression < expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    SHL             shift and go to state 91
    SHR             shift and go to state 86

  ! +               [ reduce using rule 68 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 68 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 68 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 68 (expression -> expression < expression .) ]
  ! %               [ reduce using rule 68 (expression -> expression < expression .) ]
  ! SHL             [ reduce using rule 68 (expression -> expression < expression .) ]
  ! SHR             [ reduce using rule 68 (expression -> expression < expression .) ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 145

    (63) expression -> expression SHL expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 63 (expression -> expression SHL expression .)
    &               reduce using rule 63 (expression -> expression SHL expression .)
    ^               reduce using rule 63 (expression -> expression SHL expression .)
    AND             reduce using rule 63 (expression -> expression SHL expression .)
    OR              reduce using rule 63 (expression -> expression SHL expression .)
    SHL             reduce using rule 63 (expression -> expression SHL expression .)
    SHR             reduce using rule 63 (expression -> expression SHL expression .)
    EQ              reduce using rule 63 (expression -> expression SHL expression .)
    NEQ             reduce using rule 63 (expression -> expression SHL expression .)
    >               reduce using rule 63 (expression -> expression SHL expression .)
    <               reduce using rule 63 (expression -> expression SHL expression .)
    LE              reduce using rule 63 (expression -> expression SHL expression .)
    GE              reduce using rule 63 (expression -> expression SHL expression .)
    ;               reduce using rule 63 (expression -> expression SHL expression .)
    )               reduce using rule 63 (expression -> expression SHL expression .)
    ,               reduce using rule 63 (expression -> expression SHL expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88

  ! +               [ reduce using rule 63 (expression -> expression SHL expression .) ]
  ! -               [ reduce using rule 63 (expression -> expression SHL expression .) ]
  ! *               [ reduce using rule 63 (expression -> expression SHL expression .) ]
  ! /               [ reduce using rule 63 (expression -> expression SHL expression .) ]
  ! %               [ reduce using rule 63 (expression -> expression SHL expression .) ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! SHL             [ shift and go to state 91 ]
  ! SHR             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 146

    (53) expression -> expression + expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    +               reduce using rule 53 (expression -> expression + expression .)
    -               reduce using rule 53 (expression -> expression + expression .)
    |               reduce using rule 53 (expression -> expression + expression .)
    &               reduce using rule 53 (expression -> expression + expression .)
    ^               reduce using rule 53 (expression -> expression + expression .)
    AND             reduce using rule 53 (expression -> expression + expression .)
    OR              reduce using rule 53 (expression -> expression + expression .)
    SHL             reduce using rule 53 (expression -> expression + expression .)
    SHR             reduce using rule 53 (expression -> expression + expression .)
    EQ              reduce using rule 53 (expression -> expression + expression .)
    NEQ             reduce using rule 53 (expression -> expression + expression .)
    >               reduce using rule 53 (expression -> expression + expression .)
    <               reduce using rule 53 (expression -> expression + expression .)
    LE              reduce using rule 53 (expression -> expression + expression .)
    GE              reduce using rule 53 (expression -> expression + expression .)
    ;               reduce using rule 53 (expression -> expression + expression .)
    )               reduce using rule 53 (expression -> expression + expression .)
    ,               reduce using rule 53 (expression -> expression + expression .)
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88

  ! *               [ reduce using rule 53 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 53 (expression -> expression + expression .) ]
  ! %               [ reduce using rule 53 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 92 ]
  ! -               [ shift and go to state 94 ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! SHL             [ shift and go to state 91 ]
  ! SHR             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 147

    (55) expression -> expression * expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    +               reduce using rule 55 (expression -> expression * expression .)
    -               reduce using rule 55 (expression -> expression * expression .)
    *               reduce using rule 55 (expression -> expression * expression .)
    /               reduce using rule 55 (expression -> expression * expression .)
    %               reduce using rule 55 (expression -> expression * expression .)
    |               reduce using rule 55 (expression -> expression * expression .)
    &               reduce using rule 55 (expression -> expression * expression .)
    ^               reduce using rule 55 (expression -> expression * expression .)
    AND             reduce using rule 55 (expression -> expression * expression .)
    OR              reduce using rule 55 (expression -> expression * expression .)
    SHL             reduce using rule 55 (expression -> expression * expression .)
    SHR             reduce using rule 55 (expression -> expression * expression .)
    EQ              reduce using rule 55 (expression -> expression * expression .)
    NEQ             reduce using rule 55 (expression -> expression * expression .)
    >               reduce using rule 55 (expression -> expression * expression .)
    <               reduce using rule 55 (expression -> expression * expression .)
    LE              reduce using rule 55 (expression -> expression * expression .)
    GE              reduce using rule 55 (expression -> expression * expression .)
    ;               reduce using rule 55 (expression -> expression * expression .)
    )               reduce using rule 55 (expression -> expression * expression .)
    ,               reduce using rule 55 (expression -> expression * expression .)

  ! +               [ shift and go to state 92 ]
  ! -               [ shift and go to state 94 ]
  ! *               [ shift and go to state 93 ]
  ! /               [ shift and go to state 95 ]
  ! %               [ shift and go to state 88 ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! SHL             [ shift and go to state 91 ]
  ! SHR             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 148

    (54) expression -> expression - expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    +               reduce using rule 54 (expression -> expression - expression .)
    -               reduce using rule 54 (expression -> expression - expression .)
    |               reduce using rule 54 (expression -> expression - expression .)
    &               reduce using rule 54 (expression -> expression - expression .)
    ^               reduce using rule 54 (expression -> expression - expression .)
    AND             reduce using rule 54 (expression -> expression - expression .)
    OR              reduce using rule 54 (expression -> expression - expression .)
    SHL             reduce using rule 54 (expression -> expression - expression .)
    SHR             reduce using rule 54 (expression -> expression - expression .)
    EQ              reduce using rule 54 (expression -> expression - expression .)
    NEQ             reduce using rule 54 (expression -> expression - expression .)
    >               reduce using rule 54 (expression -> expression - expression .)
    <               reduce using rule 54 (expression -> expression - expression .)
    LE              reduce using rule 54 (expression -> expression - expression .)
    GE              reduce using rule 54 (expression -> expression - expression .)
    ;               reduce using rule 54 (expression -> expression - expression .)
    )               reduce using rule 54 (expression -> expression - expression .)
    ,               reduce using rule 54 (expression -> expression - expression .)
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88

  ! *               [ reduce using rule 54 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 54 (expression -> expression - expression .) ]
  ! %               [ reduce using rule 54 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 92 ]
  ! -               [ shift and go to state 94 ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! SHL             [ shift and go to state 91 ]
  ! SHR             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 149

    (56) expression -> expression / expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    +               reduce using rule 56 (expression -> expression / expression .)
    -               reduce using rule 56 (expression -> expression / expression .)
    *               reduce using rule 56 (expression -> expression / expression .)
    /               reduce using rule 56 (expression -> expression / expression .)
    %               reduce using rule 56 (expression -> expression / expression .)
    |               reduce using rule 56 (expression -> expression / expression .)
    &               reduce using rule 56 (expression -> expression / expression .)
    ^               reduce using rule 56 (expression -> expression / expression .)
    AND             reduce using rule 56 (expression -> expression / expression .)
    OR              reduce using rule 56 (expression -> expression / expression .)
    SHL             reduce using rule 56 (expression -> expression / expression .)
    SHR             reduce using rule 56 (expression -> expression / expression .)
    EQ              reduce using rule 56 (expression -> expression / expression .)
    NEQ             reduce using rule 56 (expression -> expression / expression .)
    >               reduce using rule 56 (expression -> expression / expression .)
    <               reduce using rule 56 (expression -> expression / expression .)
    LE              reduce using rule 56 (expression -> expression / expression .)
    GE              reduce using rule 56 (expression -> expression / expression .)
    ;               reduce using rule 56 (expression -> expression / expression .)
    )               reduce using rule 56 (expression -> expression / expression .)
    ,               reduce using rule 56 (expression -> expression / expression .)

  ! +               [ shift and go to state 92 ]
  ! -               [ shift and go to state 94 ]
  ! *               [ shift and go to state 93 ]
  ! /               [ shift and go to state 95 ]
  ! %               [ shift and go to state 88 ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! SHL             [ shift and go to state 91 ]
  ! SHR             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 150

    (62) expression -> expression OR expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    OR              reduce using rule 62 (expression -> expression OR expression .)
    ;               reduce using rule 62 (expression -> expression OR expression .)
    )               reduce using rule 62 (expression -> expression OR expression .)
    ,               reduce using rule 62 (expression -> expression OR expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    AND             shift and go to state 85
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99

  ! +               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! -               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! *               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! /               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! %               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! |               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! &               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! ^               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! SHL             [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! SHR             [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! >               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! <               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 96 ]


state 151

    (65) expression -> expression EQ expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 65 (expression -> expression EQ expression .)
    &               reduce using rule 65 (expression -> expression EQ expression .)
    ^               reduce using rule 65 (expression -> expression EQ expression .)
    AND             reduce using rule 65 (expression -> expression EQ expression .)
    OR              reduce using rule 65 (expression -> expression EQ expression .)
    EQ              reduce using rule 65 (expression -> expression EQ expression .)
    NEQ             reduce using rule 65 (expression -> expression EQ expression .)
    >               reduce using rule 65 (expression -> expression EQ expression .)
    <               reduce using rule 65 (expression -> expression EQ expression .)
    LE              reduce using rule 65 (expression -> expression EQ expression .)
    GE              reduce using rule 65 (expression -> expression EQ expression .)
    ;               reduce using rule 65 (expression -> expression EQ expression .)
    )               reduce using rule 65 (expression -> expression EQ expression .)
    ,               reduce using rule 65 (expression -> expression EQ expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    SHL             shift and go to state 91
    SHR             shift and go to state 86

  ! +               [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! %               [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! SHL             [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! SHR             [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 152

    (67) expression -> expression > expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 67 (expression -> expression > expression .)
    &               reduce using rule 67 (expression -> expression > expression .)
    ^               reduce using rule 67 (expression -> expression > expression .)
    AND             reduce using rule 67 (expression -> expression > expression .)
    OR              reduce using rule 67 (expression -> expression > expression .)
    EQ              reduce using rule 67 (expression -> expression > expression .)
    NEQ             reduce using rule 67 (expression -> expression > expression .)
    >               reduce using rule 67 (expression -> expression > expression .)
    <               reduce using rule 67 (expression -> expression > expression .)
    LE              reduce using rule 67 (expression -> expression > expression .)
    GE              reduce using rule 67 (expression -> expression > expression .)
    ;               reduce using rule 67 (expression -> expression > expression .)
    )               reduce using rule 67 (expression -> expression > expression .)
    ,               reduce using rule 67 (expression -> expression > expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    SHL             shift and go to state 91
    SHR             shift and go to state 86

  ! +               [ reduce using rule 67 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 67 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 67 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 67 (expression -> expression > expression .) ]
  ! %               [ reduce using rule 67 (expression -> expression > expression .) ]
  ! SHL             [ reduce using rule 67 (expression -> expression > expression .) ]
  ! SHR             [ reduce using rule 67 (expression -> expression > expression .) ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 153

    (70) expression -> expression GE expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 70 (expression -> expression GE expression .)
    &               reduce using rule 70 (expression -> expression GE expression .)
    ^               reduce using rule 70 (expression -> expression GE expression .)
    AND             reduce using rule 70 (expression -> expression GE expression .)
    OR              reduce using rule 70 (expression -> expression GE expression .)
    EQ              reduce using rule 70 (expression -> expression GE expression .)
    NEQ             reduce using rule 70 (expression -> expression GE expression .)
    >               reduce using rule 70 (expression -> expression GE expression .)
    <               reduce using rule 70 (expression -> expression GE expression .)
    LE              reduce using rule 70 (expression -> expression GE expression .)
    GE              reduce using rule 70 (expression -> expression GE expression .)
    ;               reduce using rule 70 (expression -> expression GE expression .)
    )               reduce using rule 70 (expression -> expression GE expression .)
    ,               reduce using rule 70 (expression -> expression GE expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    SHL             shift and go to state 91
    SHR             shift and go to state 86

  ! +               [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! -               [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! *               [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! /               [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! %               [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! SHL             [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! SHR             [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 154

    (66) expression -> expression NEQ expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 66 (expression -> expression NEQ expression .)
    &               reduce using rule 66 (expression -> expression NEQ expression .)
    ^               reduce using rule 66 (expression -> expression NEQ expression .)
    AND             reduce using rule 66 (expression -> expression NEQ expression .)
    OR              reduce using rule 66 (expression -> expression NEQ expression .)
    EQ              reduce using rule 66 (expression -> expression NEQ expression .)
    NEQ             reduce using rule 66 (expression -> expression NEQ expression .)
    >               reduce using rule 66 (expression -> expression NEQ expression .)
    <               reduce using rule 66 (expression -> expression NEQ expression .)
    LE              reduce using rule 66 (expression -> expression NEQ expression .)
    GE              reduce using rule 66 (expression -> expression NEQ expression .)
    ;               reduce using rule 66 (expression -> expression NEQ expression .)
    )               reduce using rule 66 (expression -> expression NEQ expression .)
    ,               reduce using rule 66 (expression -> expression NEQ expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    SHL             shift and go to state 91
    SHR             shift and go to state 86

  ! +               [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! -               [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! *               [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! /               [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! %               [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! SHL             [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! SHR             [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! |               [ shift and go to state 102 ]
  ! &               [ shift and go to state 89 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]
  ! EQ              [ shift and go to state 97 ]
  ! NEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 98 ]
  ! <               [ shift and go to state 90 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 99 ]


state 155

    (58) expression -> expression | expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 58 (expression -> expression | expression .)
    AND             reduce using rule 58 (expression -> expression | expression .)
    OR              reduce using rule 58 (expression -> expression | expression .)
    ;               reduce using rule 58 (expression -> expression | expression .)
    )               reduce using rule 58 (expression -> expression | expression .)
    ,               reduce using rule 58 (expression -> expression | expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    &               shift and go to state 89
    ^               shift and go to state 103
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99

  ! +               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! -               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! *               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! /               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! %               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! &               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! ^               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! SHL             [ reduce using rule 58 (expression -> expression | expression .) ]
  ! SHR             [ reduce using rule 58 (expression -> expression | expression .) ]
  ! EQ              [ reduce using rule 58 (expression -> expression | expression .) ]
  ! NEQ             [ reduce using rule 58 (expression -> expression | expression .) ]
  ! >               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! <               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! LE              [ reduce using rule 58 (expression -> expression | expression .) ]
  ! GE              [ reduce using rule 58 (expression -> expression | expression .) ]
  ! |               [ shift and go to state 102 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]


state 156

    (60) expression -> expression ^ expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    |               reduce using rule 60 (expression -> expression ^ expression .)
    ^               reduce using rule 60 (expression -> expression ^ expression .)
    AND             reduce using rule 60 (expression -> expression ^ expression .)
    OR              reduce using rule 60 (expression -> expression ^ expression .)
    ;               reduce using rule 60 (expression -> expression ^ expression .)
    )               reduce using rule 60 (expression -> expression ^ expression .)
    ,               reduce using rule 60 (expression -> expression ^ expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    &               shift and go to state 89
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99

  ! +               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! -               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! *               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! /               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! %               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! &               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! SHL             [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! SHR             [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! EQ              [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! NEQ             [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! >               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! <               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! LE              [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! GE              [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! |               [ shift and go to state 102 ]
  ! ^               [ shift and go to state 103 ]
  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 96 ]


state 157

    (7) inits -> inits , init .

    ;               reduce using rule 7 (inits -> inits , init .)
    ,               reduce using rule 7 (inits -> inits , init .)


state 158

    (9) init -> id . = expression

    =               shift and go to state 109


state 159

    (83) args_list_or_empty -> args_list .
    (85) args_list -> args_list . , arg

    )               reduce using rule 83 (args_list_or_empty -> args_list .)
    ,               shift and go to state 181


state 160

    (81) fundef -> TYPE id ( args_list_or_empty . ) compound_instr

    )               shift and go to state 182


state 161

    (86) args_list -> arg .

    ,               reduce using rule 86 (args_list -> arg .)
    )               reduce using rule 86 (args_list -> arg .)


state 162

    (87) arg -> TYPE . id
    (50) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 183

state 163

    (88) arg -> id . id
    (50) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 184

state 164

    (9) init -> id = expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 9 (init -> id = expression .)
    ,               reduce using rule 9 (init -> id = expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    AND             shift and go to state 85
    OR              shift and go to state 96
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99


state 165

    (12) classinit -> id .

    ;               reduce using rule 12 (classinit -> id .)
    ,               reduce using rule 12 (classinit -> id .)


state 166

    (10) classinits -> classinits , classinit .

    ;               reduce using rule 10 (classinits -> classinits , classinit .)
    ,               reduce using rule 10 (classinits -> classinits , classinit .)


state 167

    (82) fundef -> id id ( args_list_or_empty . ) compound_instr

    )               shift and go to state 185


state 168

    (97) methoddefs -> methoddef . methoddefs
    (97) methoddefs -> . methoddef methoddefs
    (98) methoddefs -> .
    (99) methoddef -> . accessmodificator fundef
    (100) accessmodificator -> . PRIVATE
    (101) accessmodificator -> . PROTECTED
    (102) accessmodificator -> . PUBLIC

    }               reduce using rule 98 (methoddefs -> .)
    PRIVATE         shift and go to state 3
    PROTECTED       shift and go to state 4
    PUBLIC          shift and go to state 7

    methoddef                      shift and go to state 168
    accessmodificator              shift and go to state 170
    methoddefs                     shift and go to state 186

state 169

    (93) classcontent -> { fielddefs ; methoddefs . }

    }               shift and go to state 187


state 170

    (99) methoddef -> accessmodificator . fundef
    (81) fundef -> . TYPE id ( args_list_or_empty ) compound_instr
    (82) fundef -> . id id ( args_list_or_empty ) compound_instr
    (50) id -> . ID

    TYPE            shift and go to state 54
    ID              shift and go to state 11

    id                             shift and go to state 55
    fundef                         shift and go to state 188

state 171

    (32) choice_instr -> IF ( condition ) . instruction
    (33) choice_instr -> IF ( condition ) . instruction ELSE instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 189
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 172

    (34) choice_instr -> IF ( error ) . instruction
    (35) choice_instr -> IF ( error ) . instruction ELSE instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 190
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 173

    (36) while_instr -> WHILE ( condition ) . instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 191
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 174

    (37) while_instr -> WHILE ( error ) . instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 192
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 175

    (77) expr_list -> expr_list , . expression
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING
    (50) id -> . ID

    (               shift and go to state 50
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26
    ID              shift and go to state 11

    string                         shift and go to state 40
    float                          shift and go to state 24
    access                         shift and go to state 68
    integer                        shift and go to state 28
    expression                     shift and go to state 193
    id                             shift and go to state 67
    const                          shift and go to state 34

state 176

    (73) expression -> access ( expr_list_or_empty ) .

    +               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    -               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    *               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    /               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    %               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    |               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    &               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    ^               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    AND             reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    OR              reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    SHL             reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    SHR             reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    EQ              reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    NEQ             reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    >               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    <               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    LE              reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    GE              reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    ;               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    )               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)
    ,               reduce using rule 73 (expression -> access ( expr_list_or_empty ) .)


state 177

    (74) expression -> access ( error ) .

    +               reduce using rule 74 (expression -> access ( error ) .)
    -               reduce using rule 74 (expression -> access ( error ) .)
    *               reduce using rule 74 (expression -> access ( error ) .)
    /               reduce using rule 74 (expression -> access ( error ) .)
    %               reduce using rule 74 (expression -> access ( error ) .)
    |               reduce using rule 74 (expression -> access ( error ) .)
    &               reduce using rule 74 (expression -> access ( error ) .)
    ^               reduce using rule 74 (expression -> access ( error ) .)
    AND             reduce using rule 74 (expression -> access ( error ) .)
    OR              reduce using rule 74 (expression -> access ( error ) .)
    SHL             reduce using rule 74 (expression -> access ( error ) .)
    SHR             reduce using rule 74 (expression -> access ( error ) .)
    EQ              reduce using rule 74 (expression -> access ( error ) .)
    NEQ             reduce using rule 74 (expression -> access ( error ) .)
    >               reduce using rule 74 (expression -> access ( error ) .)
    <               reduce using rule 74 (expression -> access ( error ) .)
    LE              reduce using rule 74 (expression -> access ( error ) .)
    GE              reduce using rule 74 (expression -> access ( error ) .)
    ;               reduce using rule 74 (expression -> access ( error ) .)
    )               reduce using rule 74 (expression -> access ( error ) .)
    ,               reduce using rule 74 (expression -> access ( error ) .)


state 178

    (29) assignment -> access = expression ; .

    }               reduce using rule 29 (assignment -> access = expression ; .)
    (               reduce using rule 29 (assignment -> access = expression ; .)
    PRINT           reduce using rule 29 (assignment -> access = expression ; .)
    IF              reduce using rule 29 (assignment -> access = expression ; .)
    WHILE           reduce using rule 29 (assignment -> access = expression ; .)
    REPEAT          reduce using rule 29 (assignment -> access = expression ; .)
    RETURN          reduce using rule 29 (assignment -> access = expression ; .)
    BREAK           reduce using rule 29 (assignment -> access = expression ; .)
    CONTINUE        reduce using rule 29 (assignment -> access = expression ; .)
    {               reduce using rule 29 (assignment -> access = expression ; .)
    ID              reduce using rule 29 (assignment -> access = expression ; .)
    INTEGER         reduce using rule 29 (assignment -> access = expression ; .)
    FLOAT           reduce using rule 29 (assignment -> access = expression ; .)
    STRING          reduce using rule 29 (assignment -> access = expression ; .)
    $end            reduce using rule 29 (assignment -> access = expression ; .)
    UNTIL           reduce using rule 29 (assignment -> access = expression ; .)
    ELSE            reduce using rule 29 (assignment -> access = expression ; .)


state 179

    (38) repeat_instr -> REPEAT instructions UNTIL condition . ;

    ;               shift and go to state 194


state 180

    (42) compound_instr -> { declarations instructions } .

    (               reduce using rule 42 (compound_instr -> { declarations instructions } .)
    PRINT           reduce using rule 42 (compound_instr -> { declarations instructions } .)
    IF              reduce using rule 42 (compound_instr -> { declarations instructions } .)
    WHILE           reduce using rule 42 (compound_instr -> { declarations instructions } .)
    REPEAT          reduce using rule 42 (compound_instr -> { declarations instructions } .)
    RETURN          reduce using rule 42 (compound_instr -> { declarations instructions } .)
    BREAK           reduce using rule 42 (compound_instr -> { declarations instructions } .)
    CONTINUE        reduce using rule 42 (compound_instr -> { declarations instructions } .)
    {               reduce using rule 42 (compound_instr -> { declarations instructions } .)
    ID              reduce using rule 42 (compound_instr -> { declarations instructions } .)
    INTEGER         reduce using rule 42 (compound_instr -> { declarations instructions } .)
    FLOAT           reduce using rule 42 (compound_instr -> { declarations instructions } .)
    STRING          reduce using rule 42 (compound_instr -> { declarations instructions } .)
    $end            reduce using rule 42 (compound_instr -> { declarations instructions } .)
    UNTIL           reduce using rule 42 (compound_instr -> { declarations instructions } .)
    }               reduce using rule 42 (compound_instr -> { declarations instructions } .)
    ELSE            reduce using rule 42 (compound_instr -> { declarations instructions } .)
    TYPE            reduce using rule 42 (compound_instr -> { declarations instructions } .)
    PRIVATE         reduce using rule 42 (compound_instr -> { declarations instructions } .)
    PROTECTED       reduce using rule 42 (compound_instr -> { declarations instructions } .)
    PUBLIC          reduce using rule 42 (compound_instr -> { declarations instructions } .)


state 181

    (85) args_list -> args_list , . arg
    (87) arg -> . TYPE id
    (88) arg -> . id id
    (50) id -> . ID

    TYPE            shift and go to state 162
    ID              shift and go to state 11

    arg                            shift and go to state 195
    id                             shift and go to state 163

state 182

    (81) fundef -> TYPE id ( args_list_or_empty ) . compound_instr
    (42) compound_instr -> . { declarations instructions }

    {               shift and go to state 51

    compound_instr                 shift and go to state 196

state 183

    (87) arg -> TYPE id .

    ,               reduce using rule 87 (arg -> TYPE id .)
    )               reduce using rule 87 (arg -> TYPE id .)


state 184

    (88) arg -> id id .

    ,               reduce using rule 88 (arg -> id id .)
    )               reduce using rule 88 (arg -> id id .)


state 185

    (82) fundef -> id id ( args_list_or_empty ) . compound_instr
    (42) compound_instr -> . { declarations instructions }

    {               shift and go to state 51

    compound_instr                 shift and go to state 197

state 186

    (97) methoddefs -> methoddef methoddefs .

    }               reduce using rule 97 (methoddefs -> methoddef methoddefs .)


state 187

    (93) classcontent -> { fielddefs ; methoddefs } .

    PRIVATE         reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    PROTECTED       reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    PUBLIC          reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    TYPE            reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    error           reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    ID              reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    (               reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    PRINT           reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    IF              reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    WHILE           reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    REPEAT          reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    RETURN          reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    BREAK           reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    CONTINUE        reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    {               reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    INTEGER         reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    FLOAT           reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)
    STRING          reduce using rule 93 (classcontent -> { fielddefs ; methoddefs } .)


state 188

    (99) methoddef -> accessmodificator fundef .

    PRIVATE         reduce using rule 99 (methoddef -> accessmodificator fundef .)
    PROTECTED       reduce using rule 99 (methoddef -> accessmodificator fundef .)
    PUBLIC          reduce using rule 99 (methoddef -> accessmodificator fundef .)
    }               reduce using rule 99 (methoddef -> accessmodificator fundef .)


state 189

    (32) choice_instr -> IF ( condition ) instruction .
    (33) choice_instr -> IF ( condition ) instruction . ELSE instruction

    (               reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    PRINT           reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    IF              reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    WHILE           reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    REPEAT          reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    RETURN          reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    BREAK           reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    CONTINUE        reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    {               reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    ID              reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    INTEGER         reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    FLOAT           reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    STRING          reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    $end            reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    UNTIL           reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    }               reduce using rule 32 (choice_instr -> IF ( condition ) instruction .)
    ELSE            shift and go to state 198

  ! ELSE            [ reduce using rule 32 (choice_instr -> IF ( condition ) instruction .) ]


state 190

    (34) choice_instr -> IF ( error ) instruction .
    (35) choice_instr -> IF ( error ) instruction . ELSE instruction

    (               reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    PRINT           reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    IF              reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    WHILE           reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    REPEAT          reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    RETURN          reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    BREAK           reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    CONTINUE        reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    {               reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    ID              reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    INTEGER         reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    FLOAT           reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    STRING          reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    $end            reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    UNTIL           reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    }               reduce using rule 34 (choice_instr -> IF ( error ) instruction .)
    ELSE            shift and go to state 199

  ! ELSE            [ reduce using rule 34 (choice_instr -> IF ( error ) instruction .) ]


state 191

    (36) while_instr -> WHILE ( condition ) instruction .

    (               reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    PRINT           reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    IF              reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    WHILE           reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    REPEAT          reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    RETURN          reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    BREAK           reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    CONTINUE        reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    {               reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    ID              reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    INTEGER         reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    FLOAT           reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    STRING          reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    $end            reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    UNTIL           reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    }               reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)
    ELSE            reduce using rule 36 (while_instr -> WHILE ( condition ) instruction .)


state 192

    (37) while_instr -> WHILE ( error ) instruction .

    (               reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    PRINT           reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    IF              reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    WHILE           reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    REPEAT          reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    RETURN          reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    BREAK           reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    CONTINUE        reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    {               reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    ID              reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    INTEGER         reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    FLOAT           reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    STRING          reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    $end            reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    UNTIL           reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    }               reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    ELSE            reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)


state 193

    (77) expr_list -> expr_list , expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ,               reduce using rule 77 (expr_list -> expr_list , expression .)
    )               reduce using rule 77 (expr_list -> expr_list , expression .)
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    %               shift and go to state 88
    |               shift and go to state 102
    &               shift and go to state 89
    ^               shift and go to state 103
    AND             shift and go to state 85
    OR              shift and go to state 96
    SHL             shift and go to state 91
    SHR             shift and go to state 86
    EQ              shift and go to state 97
    NEQ             shift and go to state 101
    >               shift and go to state 98
    <               shift and go to state 90
    LE              shift and go to state 87
    GE              shift and go to state 99


state 194

    (38) repeat_instr -> REPEAT instructions UNTIL condition ; .

    (               reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    PRINT           reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    IF              reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    WHILE           reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    REPEAT          reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    RETURN          reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    BREAK           reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    CONTINUE        reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    {               reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    ID              reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    INTEGER         reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    FLOAT           reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    STRING          reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    $end            reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    UNTIL           reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    }               reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    ELSE            reduce using rule 38 (repeat_instr -> REPEAT instructions UNTIL condition ; .)


state 195

    (85) args_list -> args_list , arg .

    ,               reduce using rule 85 (args_list -> args_list , arg .)
    )               reduce using rule 85 (args_list -> args_list , arg .)


state 196

    (81) fundef -> TYPE id ( args_list_or_empty ) compound_instr .

    TYPE            reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    ID              reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    (               reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    PRINT           reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    IF              reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    WHILE           reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    REPEAT          reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    RETURN          reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    BREAK           reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    CONTINUE        reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    {               reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    INTEGER         reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    FLOAT           reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    STRING          reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    PRIVATE         reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    PROTECTED       reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    PUBLIC          reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)
    }               reduce using rule 81 (fundef -> TYPE id ( args_list_or_empty ) compound_instr .)


state 197

    (82) fundef -> id id ( args_list_or_empty ) compound_instr .

    TYPE            reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    ID              reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    (               reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    PRINT           reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    IF              reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    WHILE           reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    REPEAT          reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    RETURN          reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    BREAK           reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    CONTINUE        reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    {               reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    INTEGER         reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    FLOAT           reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    STRING          reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    PRIVATE         reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    PROTECTED       reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    PUBLIC          reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)
    }               reduce using rule 82 (fundef -> id id ( args_list_or_empty ) compound_instr .)


state 198

    (33) choice_instr -> IF ( condition ) instruction ELSE . instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 200
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 199

    (35) choice_instr -> IF ( error ) instruction ELSE . instruction
    (15) instruction -> . expression ;
    (16) instruction -> . print_instr
    (17) instruction -> . labeled_instr
    (18) instruction -> . assignment
    (19) instruction -> . choice_instr
    (20) instruction -> . while_instr
    (21) instruction -> . repeat_instr
    (22) instruction -> . return_instr
    (23) instruction -> . break_instr
    (24) instruction -> . continue_instr
    (25) instruction -> . compound_instr
    (51) expression -> . const
    (52) expression -> . access
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (71) expression -> . ( expression )
    (72) expression -> . ( error )
    (73) expression -> . access ( expr_list_or_empty )
    (74) expression -> . access ( error )
    (26) print_instr -> . PRINT expression ;
    (27) print_instr -> . PRINT error ;
    (28) labeled_instr -> . id : instruction
    (29) assignment -> . access = expression ;
    (32) choice_instr -> . IF ( condition ) instruction
    (33) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (34) choice_instr -> . IF ( error ) instruction
    (35) choice_instr -> . IF ( error ) instruction ELSE instruction
    (36) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (38) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (39) return_instr -> . RETURN expression ;
    (41) break_instr -> . BREAK ;
    (40) continue_instr -> . CONTINUE ;
    (42) compound_instr -> . { declarations instructions }
    (44) const -> . integer
    (45) const -> . float
    (46) const -> . string
    (30) access -> . id
    (31) access -> . id . id
    (50) id -> . ID
    (47) integer -> . INTEGER
    (48) float -> . FLOAT
    (49) string -> . STRING

    (               shift and go to state 50
    PRINT           shift and go to state 29
    IF              shift and go to state 27
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 39
    RETURN          shift and go to state 23
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 49
    {               shift and go to state 51
    ID              shift and go to state 11
    INTEGER         shift and go to state 38
    FLOAT           shift and go to state 45
    STRING          shift and go to state 26

    instruction                    shift and go to state 201
    float                          shift and go to state 24
    choice_instr                   shift and go to state 25
    id                             shift and go to state 31
    repeat_instr                   shift and go to state 32
    return_instr                   shift and go to state 33
    const                          shift and go to state 34
    continue_instr                 shift and go to state 35
    while_instr                    shift and go to state 36
    access                         shift and go to state 37
    string                         shift and go to state 40
    assignment                     shift and go to state 41
    labeled_instr                  shift and go to state 42
    compound_instr                 shift and go to state 43
    integer                        shift and go to state 28
    break_instr                    shift and go to state 46
    print_instr                    shift and go to state 48
    expression                     shift and go to state 52

state 200

    (33) choice_instr -> IF ( condition ) instruction ELSE instruction .

    (               reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    PRINT           reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    IF              reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    WHILE           reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    REPEAT          reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    RETURN          reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    BREAK           reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    {               reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ID              reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    INTEGER         reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    FLOAT           reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    STRING          reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    $end            reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    UNTIL           reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    }               reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ELSE            reduce using rule 33 (choice_instr -> IF ( condition ) instruction ELSE instruction .)


state 201

    (35) choice_instr -> IF ( error ) instruction ELSE instruction .

    (               reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    PRINT           reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    IF              reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    WHILE           reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    REPEAT          reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    RETURN          reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    BREAK           reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    {               reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ID              reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    INTEGER         reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    FLOAT           reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    STRING          reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    $end            reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    UNTIL           reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    }               reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ELSE            reduce using rule 35 (choice_instr -> IF ( error ) instruction ELSE instruction .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 10 resolved as shift
WARNING: shift/reduce conflict for ID in state 14 resolved as shift
